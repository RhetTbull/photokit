{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Python PhotoKit's Documentation","text":"<p>Python PhotoKit is a python interface to the Apple PhotoKit framework for working with the Photos app on macOS.</p> <p>This is currently a work in progress, and is not yet ready for use. I'm working on extracting the code from osxphotos and adding additional functionality.</p> <p>It is based on work done for osxphotos which provides a command line interface to the Photos app on macOS as well as a python API for working with Photos.</p>"},{"location":"#source-code","title":"Source Code","text":"<p>The source code for this project is available on GitHub.</p>"},{"location":"#installation","title":"Installation","text":"<p>Still a work in progress and not yet ready for normal use. If you'd like to experiment with it, you can install it from GitHub:</p> <pre><code>git clone git@github.com:RhetTbull/photokit.git\ncd photokit\npython3 -m pip install flit\nflit install\n</code></pre> <p>or via pip:</p> <pre><code>    pip3 install photokit\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Python PhotoKit is published under the MIT license, Copyright (c) 2023, Rhet Turnbull.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#photolibrary","title":"PhotoLibrary","text":"<p>Interface to PhotoKit PHImageManager and PHPhotoLibrary</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>class PhotoLibrary:\n\"\"\"Interface to PhotoKit PHImageManager and PHPhotoLibrary\"\"\"\n\n    def __init__(self, library_path: str | None = None):\n\"\"\"Initialize ImageManager instance.  Requests authorization to use the\n        Photos library if authorization has not already been granted.\n\n        Args:\n            library_path: str, path to Photos library to use; if None, uses default shared library\n\n        Raises:\n            PhotoKitAuthError if unable to authorize access to PhotoKit\n            PhotoKitError if attempt to call single-library mode API after multi-library mode API\n\n        Note:\n            Access to the default shared library is provided via documented PhotoKit APIs.\n            Access to other libraries via library_path is provided via undocumented private PhotoKit APIs.\n            Thus this may break at any time.\n        \"\"\"\n\n        # check authorization status\n        auth_status = PhotoLibrary.authorization_status()\n        if True not in auth_status:\n            raise PhotoKitAuthError(f\"Unable to access Photos library: {auth_status}\")\n\n        # if library_path is None, use default shared library\n        global _global_single_library_mode\n        if not library_path:\n            if not _global_single_library_mode:\n                # cannot use single-library mode APIs again after using multi-library mode APIs\n                raise PhotoKitError(\n                    \"Cannot use single-library mode APIs after using multi-library mode APIs\"\n                )\n            _global_single_library_mode = True\n            self._phimagemanager = Photos.PHCachingImageManager.defaultManager()\n            self._phphotolibrary = Photos.PHPhotoLibrary.sharedPhotoLibrary()\n            self._photosdb = PhotosDB(PhotoLibrary.system_photo_library_path())\n        else:\n            # undocumented private API to get PHPhotoLibrary for a specific library\n            Photos.PHPhotoLibrary.enableMultiLibraryMode()\n            _global_single_library_mode = False\n            self._phphotolibrary = (\n                Photos.PHPhotoLibrary.alloc().initWithPhotoLibraryURL_type_(\n                    NSURL.fileURLWithPath_(library_path), 0\n                )\n            )\n            self._phimagemanager = Photos.PHImageManager.alloc().init()\n            self._photosdb = PhotosDB(library_path)\n\n        # set by observe_changes()\n        self._change_observer = None\n        self._observed_assets = None\n\n    @staticmethod\n    def enable_multi_library_mode():\n\"\"\"Enable multi-library mode.  This is a no-op if already enabled.\n\n        Note:\n            Some PhotoKit APIs only work in multi-library mode.\n            Once enabled, it cannot be disabled and only single-library mode APIs will work.\n            In practice, you should not need to use this and PhotoLibrary will manage this automatically.\n        \"\"\"\n        Photos.PHPhotoLibrary.enableMultiLibraryMode()\n        global _global_single_library_mode\n        _global_single_library_mode = False\n\n    @staticmethod\n    def multi_library_mode() -&gt; bool:\n\"\"\"Return True if multi-library mode is enabled, False otherwise\"\"\"\n        return not _global_single_library_mode\n\n    @staticmethod\n    def system_photo_library_path() -&gt; str:\n\"\"\"Return path to system photo library\"\"\"\n        return NSURL_to_path(Photos.PHPhotoLibrary.systemPhotoLibraryURL())\n\n    @staticmethod\n    def authorization_status() -&gt; tuple[bool, bool]:\n\"\"\"Get authorization status to use user's Photos Library\n\n        Returns: tuple of bool for (read_write, add_only) authorization status\n        \"\"\"\n\n        (ver, major, _) = get_macos_version()\n        if (int(ver), int(major)) &lt; (10, 16):\n            auth_status = Photos.PHPhotoLibrary.authorizationStatus()\n            if auth_status == Photos.PHAuthorizationStatusAuthorized:\n                return (True, True)\n            return (False, False)\n\n        # requestAuthorization deprecated in 10.16/11.0\n        # use requestAuthorizationForAccessLevel instead\n        # ref: https://developer.apple.com/documentation/photokit/phphotolibrary/3616052-authorizationstatusforaccessleve?language=objc\n        read_write = Photos.PHPhotoLibrary.authorizationStatusForAccessLevel_(\n            PHAccessLevelReadWrite\n        )\n        add_only = Photos.PHPhotoLibrary.authorizationStatusForAccessLevel_(\n            PHAccessLevelAddOnly\n        )\n        return (\n            read_write == Photos.PHAuthorizationStatusAuthorized,\n            add_only == Photos.PHAuthorizationStatusAuthorized,\n        )\n\n    @staticmethod\n    def request_authorization(\n        access_level: int = PHAccessLevelReadWrite,\n    ):\n\"\"\"Request authorization to user's Photos Library\n\n        Args:\n            access_level: (int) PHAccessLevelAddOnly or PHAccessLevelReadWrite\n\n        Returns: True if authorization granted, False otherwise\n\n        Note: In actual practice, the terminal process running the python code\n            will do the actual request. This method exists for use in bundled apps\n            created with py2app, etc.  It has not yet been well tested.\n        \"\"\"\n\n        def handler(status):\n            pass\n\n        read_write, add_only = PhotoLibrary.authorization_status()\n        if (\n            access_level == PHAccessLevelReadWrite\n            and read_write\n            or access_level == PHAccessLevelAddOnly\n            and add_only\n        ):\n            # already have access\n            return True\n\n        (ver, major, _) = get_macos_version()\n        if (int(ver), int(major)) &lt; (10, 16):\n            # it seems the first try fails after Terminal prompts user for access so try again\n            for _ in range(2):\n                Photos.PHPhotoLibrary.requestAuthorization_(handler)\n                auth_status = Photos.PHPhotoLibrary.authorizationStatus()\n                if auth_status == Photos.PHAuthorizationStatusAuthorized:\n                    break\n            return bool(auth_status)\n\n        # requestAuthorization deprecated in 10.16/11.0\n        # use requestAuthorizationForAccessLevel instead\n        for _ in range(2):\n            auth_status = (\n                Photos.PHPhotoLibrary.requestAuthorizationForAccessLevel_handler_(\n                    access_level, handler\n                )\n            )\n            read_write, add_only = PhotoLibrary.authorization_status()\n            if (\n                access_level == PHAccessLevelReadWrite\n                and read_write\n                or access_level == PHAccessLevelAddOnly\n                and add_only\n            ):\n                return True\n        return bool(auth_status)\n\n    @staticmethod\n    def create_library(library_path: str | pathlib.Path | os.PathLike) -&gt; PhotoLibrary:\n\"\"\"Create a new Photos library at library_path\n\n        Args:\n            library_path: str or pathlib.Path, path to new library\n\n        Returns: PhotoLibrary object for new library\n\n        Raises:\n            FileExistsError if library already exists at library_path\n            PhotoKitCreateLibraryError if unable to create library\n\n        Note:\n            This only works in multi-library mode; multi-library mode will be enabled if not already enabled.\n            This may file (after a long timeout) if a library with same name was recently created\n            (even if it has since been deleted).\n        \"\"\"\n        library_path = (\n            str(library_path) if not isinstance(library_path, str) else library_path\n        )\n        if pathlib.Path(library_path).is_dir():\n            raise FileExistsError(f\"Library already exists at {library_path}\")\n\n        # This only works in multi-library mode\n        PhotoLibrary.enable_multi_library_mode()\n\n        # Sometimes this can generate error messages to stderr regarding CoreData XPC errors\n        # I have not yet figured out what causes this\n        # Suppress the errors with pipes() and raise error when it times out\n        # Error appears to occur if a library with same name was recently created (even if it has since been deleted)\n        with pipes() as (out, err):\n            photo_library = Photos.PHPhotoLibrary.alloc().initWithPhotoLibraryURL_type_(\n                NSURL.fileURLWithPath_(library_path), 0\n            )\n            if photo_library.createPhotoLibraryUsingOptions_error_(None, None):\n                return PhotoLibrary(library_path)\n            else:\n                raise PhotoKitCreateLibraryError(\n                    f\"Unable to create library at {library_path}\"\n                )\n\n    def library_path(self) -&gt; str:\n\"\"\"Return path to Photos library\"\"\"\n        return NSURL_to_path(self._phphotolibrary.photoLibraryURL())\n\n    def assets(self, uuids: list[str] | None = None) -&gt; list[Asset]:\n\"\"\"Return list of all assets in the library or subset filtered by UUID.\n\n        Args:\n            uuids: (list[str]) UUID of image assets to fetch; if None, fetch all assets\n\n        Returns: list of Asset objects\n\n        Note: Does not currently return assets that are hidden or in trash nor non-selected burst assets\n        \"\"\"\n        if uuids:\n            return self._assets_from_uuid_list(uuids)\n\n        if PhotoLibrary.multi_library_mode():\n            asset_uuids = self._photosdb.get_asset_uuids()\n            return self._assets_from_uuid_list(asset_uuids)\n\n        with objc.autorelease_pool():\n            options = Photos.PHFetchOptions.alloc().init()\n            # options.setIncludeHiddenAssets_(True)\n            # TODO: to access hidden photos, Photos &gt; Settings &gt; General &gt; Privacy &gt; Use Touch ID or Password\n            # must be turned off\n            # print(options.includeHiddenAssets())\n            assets = Photos.PHAsset.fetchAssetsWithOptions_(options)\n            asset_list = [assets.objectAtIndex_(idx) for idx in range(assets.count())]\n            return [self._asset_factory(asset) for asset in asset_list]\n\n    def albums(self, top_level: bool = False) -&gt; list[Album]:\n\"\"\"Return list of albums in the library\n\n        Args:\n            top_level: if True, return only top level albums\n\n        Returns: list of Album objects\n        \"\"\"\n        if PhotoLibrary.multi_library_mode():\n            album_uuids = self._photosdb.get_album_uuids(top_level=top_level)\n            return self._albums_from_uuid_list(album_uuids)\n\n        with objc.autorelease_pool():\n            # these are single library mode only\n            # this gets all user albums\n            if top_level:\n                # this gets top level albums but also folders (PHCollectionList)\n                albums = (\n                    Photos.PHCollectionList.fetchTopLevelUserCollectionsWithOptions_(\n                        None\n                    )\n                )\n            else:\n                albums = Photos.PHAssetCollection.fetchAssetCollectionsWithType_subtype_options_(\n                    Photos.PHAssetCollectionTypeAlbum,\n                    Photos.PHAssetCollectionSubtypeAny,\n                    None,\n                )\n\n            album_list = []\n            for i in range(albums.count()):\n                album = albums.objectAtIndex_(i)\n                # filter out PHCollectionList (folders), PHCloudSharedAlbum (shared albums)\n                if not isinstance(\n                    album, (Photos.PHCollectionList, Photos.PHCloudSharedAlbum)\n                ):\n                    album_list.append(album)\n            return [Album(self, album) for album in album_list]\n\n    def album(self, uuid: str | None = None, title: str | None = None) -&gt; Album:\n\"\"\"Get Album by UUID or name\n\n        Args:\n            uuid: str | None; UUID of album to fetch\n            title: str | None; title/name of album to fetch\n\n        Returns: Album object\n\n        Raises:\n            PhotoKitFetchFailed if fetch failed (album not found)\n            ValueError if both uuid and title are None or both are not None\n\n        Note: You must pass only one of uuid or title, not both. If more than one album has the same title,\n        the behavior is undefined; one of the albums will be returned but no guarantee is made as to which one.\n        \"\"\"\n\n        if not (uuid or title) or (uuid and title):\n            raise ValueError(\n                f\"Must pass either uuid or title but not both: {uuid=}, {title=}\"\n            )\n\n        if uuid:\n            try:\n                result = self._albums_from_uuid_list([uuid])\n                return result[0]\n            except Exception as e:\n                raise PhotoKitFetchFailed(\n                    f\"Fetch did not return result for uuid {uuid}: {e}\"\n                )\n\n        if title:\n            albums = self.albums()\n            for album in albums:\n                if album.title == title:\n                    return album\n            raise PhotoKitFetchFailed(f\"Fetch did not return result for title {title}\")\n\n    def create_album(self, title: str) -&gt; Album:\n\"\"\"Create a new album in the library\n\n        Args:\n            title: str, title of new album\n\n        Returns: Album object for new album\n\n        Raises:\n            PhotoKitAlbumCreateError if unable to create album\n        \"\"\"\n\n        with objc.autorelease_pool():\n            event = threading.Event()\n\n            # Create a new album\n            def completion_handler(success, error):\n                if error:\n                    raise PhotoKitAlbumCreateError(\n                        f\"Error creating album {title}: {error}\"\n                    )\n                event.set()\n\n            album_uuid = None\n\n            def create_album_handler(title):\n                nonlocal album_uuid\n\n                creation_request = Photos.PHAssetCollectionChangeRequest.creationRequestForAssetCollectionWithTitle_(\n                    title\n                )\n\n                album_uuid = (\n                    creation_request.placeholderForCreatedAssetCollection().localIdentifier()\n                )\n\n            self._phphotolibrary.performChanges_completionHandler_(\n                lambda: create_album_handler(title), completion_handler\n            )\n\n            event.wait()\n\n            return self.album(album_uuid)\n\n    def delete_album(self, album: Album):\n\"\"\"Delete album in the library\n\n        Args:\n            album: Album object to delete\n\n        Raises:\n            PhotoKitAlbumDeleteError if unable to create album\n        \"\"\"\n\n        with objc.autorelease_pool():\n            event = threading.Event()\n\n            def completion_handler(success, error):\n                if error:\n                    raise PhotoKitAlbumDeleteError(\n                        f\"Error deleting album {album}: {error}\"\n                    )\n                event.set()\n\n            def delete_album_handler(album):\n                deletion_request = (\n                    Photos.PHAssetCollectionChangeRequest.deleteAssetCollections_(\n                        [album.collection]\n                    )\n                )\n\n            self._phphotolibrary.performChanges_completionHandler_(\n                lambda: delete_album_handler(album), completion_handler\n            )\n\n            event.wait()\n\n    def folders(self):\n\"\"\" \"Return list of folders in the library\"\"\"\n        with objc.autorelease_pool():\n            # these are single library mode only\n            # this gets all user albums\n            # albums = (\n            #     Photos.PHAssetCollection.fetchAssetCollectionsWithType_subtype_options_(\n            #         Photos.PHAssetCollectionTypeAlbum,\n            #         Photos.PHAssetCollectionSubtypeAny,\n            #         None,\n            #     )\n            # )\n            #\n            # this gets top level albums but also folders (PHCollectionList)\n            folders = (\n                Photos.PHCollectionList.fetchCollectionListsWithType_subtype_options_(\n                    Photos.PHCollectionListTypeFolder,\n                    Photos.PHCollectionListSubtypeAny,\n                    None,\n                )\n            )\n            for i in range(folders.count()):\n                folder = folders.objectAtIndex_(i)\n                print(folder)\n\n    def asset(self, uuid: str) -&gt; Asset:\n\"\"\"Return Asset with uuid = uuid\n\n        Args:\n            uuid: str; UUID of image asset to fetch\n\n        Returns:\n            PhotoAsset object\n\n        Raises:\n            PhotoKitFetchFailed if fetch failed\n\n        Note:\n            uuid may be a UUID or the full local identifier of the requested asset\n        \"\"\"\n        try:\n            result = self._assets_from_uuid_list([uuid])\n            return result[0]\n        except Exception as e:\n            raise PhotoKitFetchFailed(\n                f\"Fetch did not return result for uuid {uuid}: {e}\"\n            )\n\n    def selection(self) -&gt; list[Asset]:\n\"\"\"Return list of assets currently selected in Photos app\"\"\"\n        if selected_uuids := get_selected_uuids():\n            return self.assets(selected_uuids)\n        return []\n\n    def fetch_burst_uuid(self, burstid, all=False):\n\"\"\"fetch PhotoAssets with burst ID = burstid\n\n        Args:\n            burstid: str, burst UUID\n            all: return all burst assets; if False returns only those selected by the user (including the \"key photo\" even if user hasn't manually selected it)\n\n        Returns:\n            list of PhotoAsset objects\n\n        Raises:\n            PhotoKitFetchFailed if fetch failed\n        \"\"\"\n\n        fetch_options = Photos.PHFetchOptions.alloc().init()\n        fetch_options.setIncludeAllBurstAssets_(all)\n        fetch_results = Photos.PHAsset.fetchAssetsWithBurstIdentifier_options_(\n            burstid, fetch_options\n        )\n        if fetch_results and fetch_results.count() &gt;= 1:\n            return [\n                self._asset_factory(fetch_results.objectAtIndex_(idx))\n                for idx in range(fetch_results.count())\n            ]\n        else:\n            raise PhotoKitFetchFailed(\n                f\"Fetch did not return result for burstid {burstid}\"\n            )\n\n    def delete_assets(self, photoassets: list[PhotoAsset]):\n\"\"\"Delete assets.\n\n        Args:\n            photoassets: list of PhotoAsset objects to delete\n        Note that this will prompt the user to confirm deletion of assets.\n        \"\"\"\n        with objc.autorelease_pool():\n            assets = [asset.phasset for asset in photoassets]\n            self._phphotolibrary.performChangesAndWait_error_(\n                lambda: Photos.PHAssetChangeRequest.deleteAssets_(assets), None\n            )\n\n    # // Create an asset representation of the image file\n    # [[PHPhotoLibrary sharedPhotoLibrary] performChanges:^{\n    #     PHAssetCreationRequest *creationRequest = [PHAssetCreationRequest creationRequestForAsset];\n    #     [creationRequest addResourceWithType:PHAssetResourceTypePhoto fileURL:imageURL options:nil];\n\n    #     // Add the asset to the user's Photos library\n    #     PHAssetCollectionChangeRequest *albumChangeRequest = [PHAssetCollectionChangeRequest changeRequestForAssetCollection:userLibrary];\n    #     [albumChangeRequest addAssets:@[creationRequest.placeholderForCreatedAsset]];\n\n    # } completionHandler:^(BOOL success, NSError *error) {\n    #     if (!success) {\n    #         NSLog(@\"Failed to import image into Photos library: %@\", error);\n    #     } else {\n    #         NSLog(@\"Image imported successfully.\");\n    #     }\n    # }];\n\n    def add_photo(self, photo_path: str | pathlib.Path | os.PathLike) -&gt; PhotoAsset:\n\"\"\"Add a photo to the Photos library\n\n        Args:\n            photo_path: path to image file to add\n\n        Returns:\n            PhotoAsset object for added photo\n\n        Raises:\n            FileNotFoundError if photo_path does not exist\n            PhotoKitImportError if unable to import image\n        \"\"\"\n        if not pathlib.Path(photo_path).is_file():\n            raise FileNotFoundError(f\"Could not find image file {photo_path}\")\n\n        return self._add_asset(photo_path, Photos.PHAssetResourceTypePhoto)\n\n    def add_video(self, video_path: str | pathlib.Path | os.PathLike) -&gt; VideoAsset:\n\"\"\"Add a video to the Photos library\n\n        Args:\n            video_path: path to video file to add\n\n        Returns:\n            VideoAsset object for added photo\n\n        Raises:\n            FileNotFoundError if video_path does not exist\n            PhotoKitImportError if unable to import image\n        \"\"\"\n        if not pathlib.Path(video_path).is_file():\n            raise FileNotFoundError(f\"Could not find video file {video_path}\")\n\n        return self._add_asset(video_path, Photos.PHAssetResourceTypeVideo)\n\n    def add_live_photo(\n        self,\n        photo_path: str | pathlib.Path | os.PathLike,\n        video_path: str | pathlib.Path | os.PathLike,\n    ) -&gt; LivePhotoAsset:\n\"\"\"Add a live photo/video pair to the Photos library\n\n        Args:\n            photo_path: path to image file to add\n            video_path: path to paired video file to add\n\n        Returns:\n            LivePhotoAsset object for added live photo/video pair\n\n        Raises:\n            FileNotFoundError if phto_path or video_path does not exist\n            PhotoKitImportError if unable to import image\n        \"\"\"\n        if not pathlib.Path(photo_path).is_file():\n            raise FileNotFoundError(f\"Could not find photo file {photo_path}\")\n        if not pathlib.Path(video_path).is_file():\n            raise FileNotFoundError(f\"Could not find video file {video_path}\")\n\n        return self._add_asset(\n            photo_path,\n            Photos.PHAssetResourceTypePhoto,\n            video_path,\n            Photos.PHAssetResourceTypePairedVideo,\n        )\n\n    def add_raw_pair_photo(\n        self,\n        raw_path: str | pathlib.Path | os.PathLike,\n        jpeg_path: str | pathlib.Path | os.PathLike,\n    ) -&gt; LivePhotoAsset:\n\"\"\"Add a RAW+JPEG pair to the Photos library\n\n        Args:\n            raw_path: path to RAW image file to add\n            jpeg_path: path to paired JPEG file to add\n\n        Returns:\n            PhotoAsset object for added photo pair\n\n        Raises:\n            FileNotFoundError if phto_path or video_path does not exist\n            PhotoKitImportError if unable to import image\n\n        Note:\n            The JPEG image will be treated as the \"Original\" image in Photos and\n            the paired RAW will be considered the alternate image.\n            This is consistent with Photos default behavior.\n        \"\"\"\n        if not pathlib.Path(raw_path).is_file():\n            raise FileNotFoundError(f\"Could not find photo file {raw_path}\")\n        if not pathlib.Path(jpeg_path).is_file():\n            raise FileNotFoundError(f\"Could not find photo file {jpeg_path}\")\n\n        return self._add_asset(\n            jpeg_path,\n            Photos.PHAssetResourceTypePhoto,\n            raw_path,\n            Photos.PHAssetResourceTypeAlternatePhoto,\n        )\n\n    def _add_asset(\n        self,\n        asset_path: str | pathlib.Path | os.PathLike,\n        asset_type: int,\n        asset_additional_resource_path: str | pathlib.Path | os.PathLike | None = None,\n        asset_additional_resource_type: int | None = None,\n    ) -&gt; Asset:\n\"\"\"Add an asset to the Photos library\n\n        Args:\n            asset_path: path to file to add\n            asset_type: AssetType, type of asset to add\n            asset_additional_resource_path: path to additional file to add (e.g. Live video or RAW file)\n            asset_additional_resource_type: AssetType, type of additional asset to add\n\n        Returns:\n            Asset object for added photo\n\n        Raises:\n            PhotoKitImportError if unable to import image\n        \"\"\"\n        asset_path = str(asset_path)\n        if asset_additional_resource_path:\n            if not asset_additional_resource_type:\n                raise ValueError(\"Must pass asset_additional_resource_type\")\n            asset_additional_resource_path = str(asset_additional_resource_path)\n\n        with objc.autorelease_pool():\n            asset_url = NSURL.fileURLWithPath_(asset_path)\n            asset_additional_resource_url = (\n                NSURL.fileURLWithPath_(asset_additional_resource_path)\n                if asset_additional_resource_path\n                else None\n            )\n\n            event = threading.Event()\n\n            # Create an asset representation of the image file\n            def completion_handler(success, error):\n                if error:\n                    raise PhotoKitImportError(f\"Error importing asset: {error}\")\n                event.set()\n\n            asset_uuid = None\n\n            def import_asset_changes_handler():\n                nonlocal asset_uuid\n\n                creation_request = (\n                    Photos.PHAssetCreationRequest.creationRequestForAsset()\n                )\n                creation_request.addResourceWithType_fileURL_options_(\n                    asset_type, asset_url, None\n                )\n\n                if asset_additional_resource_path:\n                    creation_request.addResourceWithType_fileURL_options_(\n                        asset_additional_resource_type,\n                        asset_additional_resource_url,\n                        None,\n                    )\n\n                asset_uuid = (\n                    creation_request.placeholderForCreatedAsset().localIdentifier()\n                )\n\n            self._phphotolibrary.performChanges_completionHandler_(\n                lambda: import_asset_changes_handler(), completion_handler\n            )\n\n            event.wait()\n\n            return self.asset(asset_uuid)\n\n    def create_keyword(self, keyword: str) -&gt; Photos.PHKeyword:\n\"\"\"Add a new keyword to the Photos library.\n\n        Args:\n            keyword: str, keyword to add\n\n        Returns: PHKeyword object for new keyword\n\n        Raises:\n            PhotoKitCreateKeywordError if unable to create keyword\n\n        Note: this does not add the keyword to any assets; it only creates the keyword in the library.\n        Keywords must be created in the library before they can be added to assets.\n\n        In general you should be able to use Asset().keywords setter to add a keyword to an asset without\n        calling this method directly.\n        \"\"\"\n\n        with objc.autorelease_pool():\n            event = threading.Event()\n\n            # Create a new keyword in the library\n            def completion_handler(success, error):\n                if error:\n                    raise PhotoKitCreateKeywordError(f\"Error creating keyword: {error}\")\n                event.set()\n\n            keyword_uuid = None\n\n            def create_keyword_change_handler(keyword):\n                nonlocal keyword_uuid\n\n                creation_request = (\n                    Photos.PHKeywordChangeRequest.creationRequestForKeyword()\n                )\n                creation_request.setTitle_(keyword)\n\n                keyword_uuid = (\n                    creation_request.placeholderForCreatedKeyword().localIdentifier()\n                )\n\n            self._phphotolibrary.performChanges_completionHandler_(\n                lambda: create_keyword_change_handler(keyword), completion_handler\n            )\n\n            event.wait()\n            logger.debug(f\"Created keyword {keyword} with uuid {keyword_uuid}\")\n\n            if keyword_object := self._keywords_from_title_list([keyword]):\n                return keyword_object[0]\n            else:\n                raise PhotoKitCreateKeywordError(f\"Error creating keyword {keyword}\")\n\n    def smart_album(\n        self,\n        album_name: str | None = None,\n        album_type: PhotoLibrarySmartAlbumType | None = None,\n        user: bool = False,\n    ) -&gt; Album:\n\"\"\"Get smart album with given name\n\n        Args:\n            album_name: name of smart album to fetch\n            album_type: PhotoLibrarySmartAlbumType of smart album to fetch\n            user: if True, fetch user smart album instead of system smart album\n\n        Returns: Album object for smart album\n\n        Raises:\n            PhotoKitFetchFailed if fetch failed (album not found)\n            ValueError if both album_name and album_type are None or both are not None\n\n        Note: This only works in single library mode. If more than one album has the same name,\n        the first one found will be returned but no guarantee is made as to which one.\n        \"\"\"\n\n        if PhotoLibrary.multi_library_mode():\n            raise NotImplementedError(\n                \"Fetching smart albums not implemented in multi-library mode\"\n            )\n\n        if (album_name and album_type) or (not album_name and not album_type):\n            raise ValueError(\n                f\"Must pass one of album_name or album_type: {album_name=}, {album_type=}\"\n            )\n\n        # single library mode\n        subtype = album_type.value if album_type else 0\n        with objc.autorelease_pool():\n            options = Photos.PHFetchOptions.alloc().init()\n            if user:\n                options.setIncludeUserSmartAlbums_(True)\n            albums = (\n                Photos.PHAssetCollection.fetchAssetCollectionsWithType_subtype_options_(\n                    Photos.PHAssetCollectionTypeSmartAlbum,\n                    subtype,\n                    options,\n                )\n            )\n\n            # album type\n            if album_type:\n                if not albums.count():\n                    raise PhotoKitFetchFailed(\n                        f\"Fetch did not return result for album_type {album_type}\"\n                    )\n                return Album(self, albums.objectAtIndex_(0))\n\n            # album name\n            for i in range(albums.count()):\n                album = albums.objectAtIndex_(i)\n                if album.localizedTitle() == album_name and (\n                    not user or album.isUserSmartAlbum()\n                ):\n                    return Album(self, album)\n            raise PhotoKitFetchFailed(\n                f\"Fetch did not return result for album {album_name}\"\n            )\n\n    def smart_albums(self, user: bool = False) -&gt; list[Album]:\n\"\"\"Get list of smart albums\n\n        Args:\n            user: if True, fetch user smart albums instead of system smart albums\n\n        Returns: list of Album objects for smart albums\n\n        Raises:\n            PhotoKitFetchFailed if fetch failed (album not found)\n\n        Note: This only works in single library mode\n        \"\"\"\n\n        if PhotoLibrary.multi_library_mode():\n            raise NotImplementedError(\n                \"Fetching smart albums not implemented in multi-library mode\"\n            )\n\n        # single library mode\n        subtype = 0\n        with objc.autorelease_pool():\n            options = Photos.PHFetchOptions.alloc().init()\n            if user:\n                options.setIncludeUserSmartAlbums_(True)\n            albums = (\n                Photos.PHAssetCollection.fetchAssetCollectionsWithType_subtype_options_(\n                    Photos.PHAssetCollectionTypeSmartAlbum,\n                    subtype,\n                    options,\n                )\n            )\n\n            album_list = []\n            for i in range(albums.count()):\n                album = albums.objectAtIndex_(i)\n                if user and not album.isUserSmartAlbum():\n                    continue\n                elif not user and album.isUserSmartAlbum():\n                    continue\n                album_list.append(Album(self, album))\n\n            if not album_list:\n                raise PhotoKitFetchFailed(\n                    f\"Fetch did not return result for smart albums\"\n                )\n\n            return album_list\n\n    def observe_changes(self, callback: Callable[[AssetChanges], None]):\n\"\"\"Observe changes to the library and call callback when changes occur\"\"\"\n        if PhotoLibrary.multi_library_mode():\n            raise NotImplementedError(\n                \"Observing changes not implemented in multi-library mode\"\n            )\n        with objc.autorelease_pool():\n            self._callback = callback\n            options = Photos.PHFetchOptions.alloc().init()\n            self._observed_assets = Photos.PHAsset.fetchAssetsWithOptions_(options)\n            # ZZZ need a way to fetch assets from the screenshot collection\n            # fetchAssetsInAssetCollection:options:\n            # and pass in the fetch to observe_changes\n        self._phphotolibrary.registerChangeObserver_(self)\n\n    def stop_observing_changes(self):\n\"\"\"Stop observing changes to the library\"\"\"\n        if self._callback:\n            self._phphotolibrary.unregisterChangeObserver_(self)\n\n    def photoLibraryDidChange_(self, change_instance):\n\"\"\"Handle a change to the Photo library\"\"\"\n        if not self._callback:\n            raise PhotoKitError(\"No callback registered for change observer\")\n        if not callable(self._callback):\n            raise PhotoKitError(\"Callback is not callable\")\n\n        if not change_instance:\n            return\n\n        with objc.autorelease_pool():\n            change_details = change_instance.changeDetailsForFetchResult_(\n                self._observed_assets\n            )\n            if change_details:\n                if change_details.hasIncrementalChanges() and (\n                    change_details.insertedObjects().count() &gt; 0\n                    or change_details.removedObjects().count() &gt; 0\n                    or change_details.changedObjects().count() &gt; 0\n                ):\n                    added = [\n                        self._asset_factory(\n                            change_details.insertedObjects().objectAtIndex_(i)\n                        )\n                        for i in range(change_details.insertedObjects().count())\n                    ]\n                    removed = [\n                        self._asset_factory(\n                            change_details.removedObjects().objectAtIndex_(i)\n                        )\n                        for i in range(change_details.removedObjects().count())\n                    ]\n                    updated = [\n                        self._asset_factory(\n                            change_details.changedObjects().objectAtIndex_(i)\n                        )\n                        for i in range(change_details.changedObjects().count())\n                    ]\n                    self._callback(AssetChanges(added, removed, updated))\n\n    def _albums_from_uuid_list(self, uuids: list[str]) -&gt; list[Album]:\n\"\"\"Get albums from list of uuids\n\n        Args:\n            uuids: list of str (UUID of image assets to fetch)\n\n        Returns: list of Album objects\n\n        Raises:\n            PhotoKitFetchFailed if fetch failed\n        \"\"\"\n\n        uuids = [uuid.split(\"/\")[0] for uuid in uuids]\n        with objc.autorelease_pool():\n            if PhotoLibrary.multi_library_mode():\n                fetch_object = NSString.stringWithString_(\"Album\")\n                if fetch_result := self._phphotolibrary.fetchPHObjectsForUUIDs_entityName_(\n                    uuids, fetch_object\n                ):\n                    return [\n                        Album(self, fetch_result.objectAtIndex_(idx))\n                        for idx in range(fetch_result.count())\n                    ]\n                else:\n                    raise PhotoKitFetchFailed(\n                        f\"Fetch did not return result for uuid_list {uuids}\"\n                    )\n\n            # single library mode\n            albums = self.albums()\n            return [album for album in albums if album.uuid in uuids]\n\n    def _assets_from_uuid_list(self, uuids: list[str]) -&gt; list[Asset]:\n\"\"\"Get assets from list of uuids\n\n        Args:\n            uuids: list of str (UUID of image assets to fetch)\n\n        Returns: list of Asset objects\n\n        Raises:\n            PhotoKitFetchFailed if fetch failed\n        \"\"\"\n\n        # uuids may be full local identifiers (e.g. \"1F2A3B4C-5D6E-7F8A-9B0C-D1E2F3A4B5C6/L0/001\")\n        # if so, strip off the \"/L0/001\" part\n        uuids = [uuid.split(\"/\")[0] for uuid in uuids]\n\n        with objc.autorelease_pool():\n            if PhotoLibrary.multi_library_mode():\n                fetch_object = NSString.stringWithString_(\"Asset\")\n                if fetch_result := self._phphotolibrary.fetchPHObjectsForUUIDs_entityName_(\n                    uuids, fetch_object\n                ):\n                    return [\n                        self._asset_factory(fetch_result.objectAtIndex_(idx))\n                        for idx in range(fetch_result.count())\n                    ]\n                else:\n                    raise PhotoKitFetchFailed(\n                        f\"Fetch did not return result for uuid_list {uuids}\"\n                    )\n\n            fetch_options = Photos.PHFetchOptions.alloc().init()\n            fetch_result = Photos.PHAsset.fetchAssetsWithLocalIdentifiers_options_(\n                uuids, fetch_options\n            )\n            if fetch_result and fetch_result.count() &gt;= 1:\n                return [\n                    self._asset_factory(fetch_result.objectAtIndex_(idx))\n                    for idx in range(fetch_result.count())\n                ]\n            else:\n                raise PhotoKitFetchFailed(\n                    f\"Fetch did not return result for uuid_list {uuids}\"\n                )\n\n    def _keywords_from_title_list(self, titles: list[str]) -&gt; list[Photos.PHKeyword]:\n\"\"\"Fetch keywords from the library with given titles\n\n        Args:\n            titles: list of str (titles of keywords to fetch)\n\n        Returns: list of PHKeyword objects\n        \"\"\"\n        if not titles:\n            return []\n\n        if PhotoLibrary.multi_library_mode():\n            uuids = self._photosdb.get_keyword_uuids_for_keywords(titles)\n            fetch_object = NSString.stringWithString_(\"Keyword\")\n            if fetch_result := self._phphotolibrary.fetchPHObjectsForUUIDs_entityName_(\n                uuids, fetch_object\n            ):\n                return [\n                    fetch_result.objectAtIndex_(idx)\n                    for idx in range(fetch_result.count())\n                ]\n            else:\n                raise PhotoKitFetchFailed(\n                    f\"Fetch did not return result for titles {titles}\"\n                )\n\n        # single library mode\n        return _fetch_keywords(titles)\n\n    def _default_album(self):\n\"\"\"Fetch the default Photos album\"\"\"\n        if PhotoLibrary.multi_library_mode():\n            raise NotImplementedError(\n                \"Fetching default album not implemented in multi-library mode\"\n            )\n\n        # single library mode\n        smart_albums = (\n            Photos.PHAssetCollection.fetchAssetCollectionsWithType_subtype_options_(\n                Photos.PHAssetCollectionTypeSmartAlbum,\n                Photos.PHAssetCollectionSubtypeSmartAlbumUserLibrary,\n                None,\n            )\n        )\n        default_album = smart_albums.firstObject()\n        return default_album\n\n    def _asset_factory(self, phasset: Photos.PHAsset) -&gt; Asset:\n\"\"\"creates a PhotoAsset, VideoAsset, or LivePhotoAsset\n\n        Args:\n            phasset: PHAsset object\n\n        Returns:\n            PhotoAsset, VideoAsset, or LivePhotoAsset depending on type of PHAsset\n        \"\"\"\n\n        if not isinstance(phasset, Photos.PHAsset):\n            raise TypeError(\"phasset must be type PHAsset\")\n\n        media_type = phasset.mediaType()\n        media_subtypes = phasset.mediaSubtypes()\n\n        if media_subtypes &amp; Photos.PHAssetMediaSubtypePhotoLive:\n            return LivePhotoAsset(self, phasset)\n        elif media_type == Photos.PHAssetMediaTypeImage:\n            return PhotoAsset(self, phasset)\n        elif media_type == Photos.PHAssetMediaTypeVideo:\n            return VideoAsset(self, phasset)\n        else:\n            raise PhotoKitMediaTypeError(f\"Unknown media type: {media_type}\")\n\n    def __len__(self):\n\"\"\"Return number of assets in library\"\"\"\n        return len(self.assets())\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.__init__","title":"<code>__init__(library_path=None)</code>","text":"<p>Initialize ImageManager instance.  Requests authorization to use the Photos library if authorization has not already been granted.</p> <p>Parameters:</p> Name Type Description Default <code>library_path</code> <code>str | None</code> <p>str, path to Photos library to use; if None, uses default shared library</p> <code>None</code> Note <p>Access to the default shared library is provided via documented PhotoKit APIs. Access to other libraries via library_path is provided via undocumented private PhotoKit APIs. Thus this may break at any time.</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def __init__(self, library_path: str | None = None):\n\"\"\"Initialize ImageManager instance.  Requests authorization to use the\n    Photos library if authorization has not already been granted.\n\n    Args:\n        library_path: str, path to Photos library to use; if None, uses default shared library\n\n    Raises:\n        PhotoKitAuthError if unable to authorize access to PhotoKit\n        PhotoKitError if attempt to call single-library mode API after multi-library mode API\n\n    Note:\n        Access to the default shared library is provided via documented PhotoKit APIs.\n        Access to other libraries via library_path is provided via undocumented private PhotoKit APIs.\n        Thus this may break at any time.\n    \"\"\"\n\n    # check authorization status\n    auth_status = PhotoLibrary.authorization_status()\n    if True not in auth_status:\n        raise PhotoKitAuthError(f\"Unable to access Photos library: {auth_status}\")\n\n    # if library_path is None, use default shared library\n    global _global_single_library_mode\n    if not library_path:\n        if not _global_single_library_mode:\n            # cannot use single-library mode APIs again after using multi-library mode APIs\n            raise PhotoKitError(\n                \"Cannot use single-library mode APIs after using multi-library mode APIs\"\n            )\n        _global_single_library_mode = True\n        self._phimagemanager = Photos.PHCachingImageManager.defaultManager()\n        self._phphotolibrary = Photos.PHPhotoLibrary.sharedPhotoLibrary()\n        self._photosdb = PhotosDB(PhotoLibrary.system_photo_library_path())\n    else:\n        # undocumented private API to get PHPhotoLibrary for a specific library\n        Photos.PHPhotoLibrary.enableMultiLibraryMode()\n        _global_single_library_mode = False\n        self._phphotolibrary = (\n            Photos.PHPhotoLibrary.alloc().initWithPhotoLibraryURL_type_(\n                NSURL.fileURLWithPath_(library_path), 0\n            )\n        )\n        self._phimagemanager = Photos.PHImageManager.alloc().init()\n        self._photosdb = PhotosDB(library_path)\n\n    # set by observe_changes()\n    self._change_observer = None\n    self._observed_assets = None\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.__len__","title":"<code>__len__()</code>","text":"<p>Return number of assets in library</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def __len__(self):\n\"\"\"Return number of assets in library\"\"\"\n    return len(self.assets())\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.add_live_photo","title":"<code>add_live_photo(photo_path, video_path)</code>","text":"<p>Add a live photo/video pair to the Photos library</p> <p>Parameters:</p> Name Type Description Default <code>photo_path</code> <code>str | Path | PathLike</code> <p>path to image file to add</p> required <code>video_path</code> <code>str | Path | PathLike</code> <p>path to paired video file to add</p> required <p>Returns:</p> Type Description <code>LivePhotoAsset</code> <p>LivePhotoAsset object for added live photo/video pair</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def add_live_photo(\n    self,\n    photo_path: str | pathlib.Path | os.PathLike,\n    video_path: str | pathlib.Path | os.PathLike,\n) -&gt; LivePhotoAsset:\n\"\"\"Add a live photo/video pair to the Photos library\n\n    Args:\n        photo_path: path to image file to add\n        video_path: path to paired video file to add\n\n    Returns:\n        LivePhotoAsset object for added live photo/video pair\n\n    Raises:\n        FileNotFoundError if phto_path or video_path does not exist\n        PhotoKitImportError if unable to import image\n    \"\"\"\n    if not pathlib.Path(photo_path).is_file():\n        raise FileNotFoundError(f\"Could not find photo file {photo_path}\")\n    if not pathlib.Path(video_path).is_file():\n        raise FileNotFoundError(f\"Could not find video file {video_path}\")\n\n    return self._add_asset(\n        photo_path,\n        Photos.PHAssetResourceTypePhoto,\n        video_path,\n        Photos.PHAssetResourceTypePairedVideo,\n    )\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.add_photo","title":"<code>add_photo(photo_path)</code>","text":"<p>Add a photo to the Photos library</p> <p>Parameters:</p> Name Type Description Default <code>photo_path</code> <code>str | Path | PathLike</code> <p>path to image file to add</p> required <p>Returns:</p> Type Description <code>PhotoAsset</code> <p>PhotoAsset object for added photo</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def add_photo(self, photo_path: str | pathlib.Path | os.PathLike) -&gt; PhotoAsset:\n\"\"\"Add a photo to the Photos library\n\n    Args:\n        photo_path: path to image file to add\n\n    Returns:\n        PhotoAsset object for added photo\n\n    Raises:\n        FileNotFoundError if photo_path does not exist\n        PhotoKitImportError if unable to import image\n    \"\"\"\n    if not pathlib.Path(photo_path).is_file():\n        raise FileNotFoundError(f\"Could not find image file {photo_path}\")\n\n    return self._add_asset(photo_path, Photos.PHAssetResourceTypePhoto)\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.add_raw_pair_photo","title":"<code>add_raw_pair_photo(raw_path, jpeg_path)</code>","text":"<p>Add a RAW+JPEG pair to the Photos library</p> <p>Parameters:</p> Name Type Description Default <code>raw_path</code> <code>str | Path | PathLike</code> <p>path to RAW image file to add</p> required <code>jpeg_path</code> <code>str | Path | PathLike</code> <p>path to paired JPEG file to add</p> required <p>Returns:</p> Type Description <code>LivePhotoAsset</code> <p>PhotoAsset object for added photo pair</p> Note <p>The JPEG image will be treated as the \"Original\" image in Photos and the paired RAW will be considered the alternate image. This is consistent with Photos default behavior.</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def add_raw_pair_photo(\n    self,\n    raw_path: str | pathlib.Path | os.PathLike,\n    jpeg_path: str | pathlib.Path | os.PathLike,\n) -&gt; LivePhotoAsset:\n\"\"\"Add a RAW+JPEG pair to the Photos library\n\n    Args:\n        raw_path: path to RAW image file to add\n        jpeg_path: path to paired JPEG file to add\n\n    Returns:\n        PhotoAsset object for added photo pair\n\n    Raises:\n        FileNotFoundError if phto_path or video_path does not exist\n        PhotoKitImportError if unable to import image\n\n    Note:\n        The JPEG image will be treated as the \"Original\" image in Photos and\n        the paired RAW will be considered the alternate image.\n        This is consistent with Photos default behavior.\n    \"\"\"\n    if not pathlib.Path(raw_path).is_file():\n        raise FileNotFoundError(f\"Could not find photo file {raw_path}\")\n    if not pathlib.Path(jpeg_path).is_file():\n        raise FileNotFoundError(f\"Could not find photo file {jpeg_path}\")\n\n    return self._add_asset(\n        jpeg_path,\n        Photos.PHAssetResourceTypePhoto,\n        raw_path,\n        Photos.PHAssetResourceTypeAlternatePhoto,\n    )\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.add_video","title":"<code>add_video(video_path)</code>","text":"<p>Add a video to the Photos library</p> <p>Parameters:</p> Name Type Description Default <code>video_path</code> <code>str | Path | PathLike</code> <p>path to video file to add</p> required <p>Returns:</p> Type Description <code>VideoAsset</code> <p>VideoAsset object for added photo</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def add_video(self, video_path: str | pathlib.Path | os.PathLike) -&gt; VideoAsset:\n\"\"\"Add a video to the Photos library\n\n    Args:\n        video_path: path to video file to add\n\n    Returns:\n        VideoAsset object for added photo\n\n    Raises:\n        FileNotFoundError if video_path does not exist\n        PhotoKitImportError if unable to import image\n    \"\"\"\n    if not pathlib.Path(video_path).is_file():\n        raise FileNotFoundError(f\"Could not find video file {video_path}\")\n\n    return self._add_asset(video_path, Photos.PHAssetResourceTypeVideo)\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.album","title":"<code>album(uuid=None, title=None)</code>","text":"<p>Get Album by UUID or name</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str | None</code> <p>str | None; UUID of album to fetch</p> <code>None</code> <code>title</code> <code>str | None</code> <p>str | None; title/name of album to fetch</p> <code>None</code> <p>Returns: Album object</p> <p>Note: You must pass only one of uuid or title, not both. If more than one album has the same title, the behavior is undefined; one of the albums will be returned but no guarantee is made as to which one.</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def album(self, uuid: str | None = None, title: str | None = None) -&gt; Album:\n\"\"\"Get Album by UUID or name\n\n    Args:\n        uuid: str | None; UUID of album to fetch\n        title: str | None; title/name of album to fetch\n\n    Returns: Album object\n\n    Raises:\n        PhotoKitFetchFailed if fetch failed (album not found)\n        ValueError if both uuid and title are None or both are not None\n\n    Note: You must pass only one of uuid or title, not both. If more than one album has the same title,\n    the behavior is undefined; one of the albums will be returned but no guarantee is made as to which one.\n    \"\"\"\n\n    if not (uuid or title) or (uuid and title):\n        raise ValueError(\n            f\"Must pass either uuid or title but not both: {uuid=}, {title=}\"\n        )\n\n    if uuid:\n        try:\n            result = self._albums_from_uuid_list([uuid])\n            return result[0]\n        except Exception as e:\n            raise PhotoKitFetchFailed(\n                f\"Fetch did not return result for uuid {uuid}: {e}\"\n            )\n\n    if title:\n        albums = self.albums()\n        for album in albums:\n            if album.title == title:\n                return album\n        raise PhotoKitFetchFailed(f\"Fetch did not return result for title {title}\")\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.albums","title":"<code>albums(top_level=False)</code>","text":"<p>Return list of albums in the library</p> <p>Parameters:</p> Name Type Description Default <code>top_level</code> <code>bool</code> <p>if True, return only top level albums</p> <code>False</code> <p>Returns: list of Album objects</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def albums(self, top_level: bool = False) -&gt; list[Album]:\n\"\"\"Return list of albums in the library\n\n    Args:\n        top_level: if True, return only top level albums\n\n    Returns: list of Album objects\n    \"\"\"\n    if PhotoLibrary.multi_library_mode():\n        album_uuids = self._photosdb.get_album_uuids(top_level=top_level)\n        return self._albums_from_uuid_list(album_uuids)\n\n    with objc.autorelease_pool():\n        # these are single library mode only\n        # this gets all user albums\n        if top_level:\n            # this gets top level albums but also folders (PHCollectionList)\n            albums = (\n                Photos.PHCollectionList.fetchTopLevelUserCollectionsWithOptions_(\n                    None\n                )\n            )\n        else:\n            albums = Photos.PHAssetCollection.fetchAssetCollectionsWithType_subtype_options_(\n                Photos.PHAssetCollectionTypeAlbum,\n                Photos.PHAssetCollectionSubtypeAny,\n                None,\n            )\n\n        album_list = []\n        for i in range(albums.count()):\n            album = albums.objectAtIndex_(i)\n            # filter out PHCollectionList (folders), PHCloudSharedAlbum (shared albums)\n            if not isinstance(\n                album, (Photos.PHCollectionList, Photos.PHCloudSharedAlbum)\n            ):\n                album_list.append(album)\n        return [Album(self, album) for album in album_list]\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.asset","title":"<code>asset(uuid)</code>","text":"<p>Return Asset with uuid = uuid</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>str; UUID of image asset to fetch</p> required <p>Returns:</p> Type Description <code>Asset</code> <p>PhotoAsset object</p> Note <p>uuid may be a UUID or the full local identifier of the requested asset</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def asset(self, uuid: str) -&gt; Asset:\n\"\"\"Return Asset with uuid = uuid\n\n    Args:\n        uuid: str; UUID of image asset to fetch\n\n    Returns:\n        PhotoAsset object\n\n    Raises:\n        PhotoKitFetchFailed if fetch failed\n\n    Note:\n        uuid may be a UUID or the full local identifier of the requested asset\n    \"\"\"\n    try:\n        result = self._assets_from_uuid_list([uuid])\n        return result[0]\n    except Exception as e:\n        raise PhotoKitFetchFailed(\n            f\"Fetch did not return result for uuid {uuid}: {e}\"\n        )\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.assets","title":"<code>assets(uuids=None)</code>","text":"<p>Return list of all assets in the library or subset filtered by UUID.</p> <p>Parameters:</p> Name Type Description Default <code>uuids</code> <code>list[str] | None</code> <p>(list[str]) UUID of image assets to fetch; if None, fetch all assets</p> <code>None</code> <p>Returns: list of Asset objects</p> <p>Note: Does not currently return assets that are hidden or in trash nor non-selected burst assets</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def assets(self, uuids: list[str] | None = None) -&gt; list[Asset]:\n\"\"\"Return list of all assets in the library or subset filtered by UUID.\n\n    Args:\n        uuids: (list[str]) UUID of image assets to fetch; if None, fetch all assets\n\n    Returns: list of Asset objects\n\n    Note: Does not currently return assets that are hidden or in trash nor non-selected burst assets\n    \"\"\"\n    if uuids:\n        return self._assets_from_uuid_list(uuids)\n\n    if PhotoLibrary.multi_library_mode():\n        asset_uuids = self._photosdb.get_asset_uuids()\n        return self._assets_from_uuid_list(asset_uuids)\n\n    with objc.autorelease_pool():\n        options = Photos.PHFetchOptions.alloc().init()\n        # options.setIncludeHiddenAssets_(True)\n        # TODO: to access hidden photos, Photos &gt; Settings &gt; General &gt; Privacy &gt; Use Touch ID or Password\n        # must be turned off\n        # print(options.includeHiddenAssets())\n        assets = Photos.PHAsset.fetchAssetsWithOptions_(options)\n        asset_list = [assets.objectAtIndex_(idx) for idx in range(assets.count())]\n        return [self._asset_factory(asset) for asset in asset_list]\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.authorization_status","title":"<code>authorization_status()</code>  <code>staticmethod</code>","text":"<p>Get authorization status to use user's Photos Library</p> <p>Returns: tuple of bool for (read_write, add_only) authorization status</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>@staticmethod\ndef authorization_status() -&gt; tuple[bool, bool]:\n\"\"\"Get authorization status to use user's Photos Library\n\n    Returns: tuple of bool for (read_write, add_only) authorization status\n    \"\"\"\n\n    (ver, major, _) = get_macos_version()\n    if (int(ver), int(major)) &lt; (10, 16):\n        auth_status = Photos.PHPhotoLibrary.authorizationStatus()\n        if auth_status == Photos.PHAuthorizationStatusAuthorized:\n            return (True, True)\n        return (False, False)\n\n    # requestAuthorization deprecated in 10.16/11.0\n    # use requestAuthorizationForAccessLevel instead\n    # ref: https://developer.apple.com/documentation/photokit/phphotolibrary/3616052-authorizationstatusforaccessleve?language=objc\n    read_write = Photos.PHPhotoLibrary.authorizationStatusForAccessLevel_(\n        PHAccessLevelReadWrite\n    )\n    add_only = Photos.PHPhotoLibrary.authorizationStatusForAccessLevel_(\n        PHAccessLevelAddOnly\n    )\n    return (\n        read_write == Photos.PHAuthorizationStatusAuthorized,\n        add_only == Photos.PHAuthorizationStatusAuthorized,\n    )\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.create_album","title":"<code>create_album(title)</code>","text":"<p>Create a new album in the library</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>str, title of new album</p> required <p>Returns: Album object for new album</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def create_album(self, title: str) -&gt; Album:\n\"\"\"Create a new album in the library\n\n    Args:\n        title: str, title of new album\n\n    Returns: Album object for new album\n\n    Raises:\n        PhotoKitAlbumCreateError if unable to create album\n    \"\"\"\n\n    with objc.autorelease_pool():\n        event = threading.Event()\n\n        # Create a new album\n        def completion_handler(success, error):\n            if error:\n                raise PhotoKitAlbumCreateError(\n                    f\"Error creating album {title}: {error}\"\n                )\n            event.set()\n\n        album_uuid = None\n\n        def create_album_handler(title):\n            nonlocal album_uuid\n\n            creation_request = Photos.PHAssetCollectionChangeRequest.creationRequestForAssetCollectionWithTitle_(\n                title\n            )\n\n            album_uuid = (\n                creation_request.placeholderForCreatedAssetCollection().localIdentifier()\n            )\n\n        self._phphotolibrary.performChanges_completionHandler_(\n            lambda: create_album_handler(title), completion_handler\n        )\n\n        event.wait()\n\n        return self.album(album_uuid)\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.create_keyword","title":"<code>create_keyword(keyword)</code>","text":"<p>Add a new keyword to the Photos library.</p> <p>Parameters:</p> Name Type Description Default <code>keyword</code> <code>str</code> <p>str, keyword to add</p> required <p>Returns: PHKeyword object for new keyword</p> <p>Note: this does not add the keyword to any assets; it only creates the keyword in the library. Keywords must be created in the library before they can be added to assets.</p> <p>In general you should be able to use Asset().keywords setter to add a keyword to an asset without calling this method directly.</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def create_keyword(self, keyword: str) -&gt; Photos.PHKeyword:\n\"\"\"Add a new keyword to the Photos library.\n\n    Args:\n        keyword: str, keyword to add\n\n    Returns: PHKeyword object for new keyword\n\n    Raises:\n        PhotoKitCreateKeywordError if unable to create keyword\n\n    Note: this does not add the keyword to any assets; it only creates the keyword in the library.\n    Keywords must be created in the library before they can be added to assets.\n\n    In general you should be able to use Asset().keywords setter to add a keyword to an asset without\n    calling this method directly.\n    \"\"\"\n\n    with objc.autorelease_pool():\n        event = threading.Event()\n\n        # Create a new keyword in the library\n        def completion_handler(success, error):\n            if error:\n                raise PhotoKitCreateKeywordError(f\"Error creating keyword: {error}\")\n            event.set()\n\n        keyword_uuid = None\n\n        def create_keyword_change_handler(keyword):\n            nonlocal keyword_uuid\n\n            creation_request = (\n                Photos.PHKeywordChangeRequest.creationRequestForKeyword()\n            )\n            creation_request.setTitle_(keyword)\n\n            keyword_uuid = (\n                creation_request.placeholderForCreatedKeyword().localIdentifier()\n            )\n\n        self._phphotolibrary.performChanges_completionHandler_(\n            lambda: create_keyword_change_handler(keyword), completion_handler\n        )\n\n        event.wait()\n        logger.debug(f\"Created keyword {keyword} with uuid {keyword_uuid}\")\n\n        if keyword_object := self._keywords_from_title_list([keyword]):\n            return keyword_object[0]\n        else:\n            raise PhotoKitCreateKeywordError(f\"Error creating keyword {keyword}\")\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.create_library","title":"<code>create_library(library_path)</code>  <code>staticmethod</code>","text":"<p>Create a new Photos library at library_path</p> <p>Parameters:</p> Name Type Description Default <code>library_path</code> <code>str | Path | PathLike</code> <p>str or pathlib.Path, path to new library</p> required <p>Returns: PhotoLibrary object for new library</p> Note <p>This only works in multi-library mode; multi-library mode will be enabled if not already enabled. This may file (after a long timeout) if a library with same name was recently created (even if it has since been deleted).</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>@staticmethod\ndef create_library(library_path: str | pathlib.Path | os.PathLike) -&gt; PhotoLibrary:\n\"\"\"Create a new Photos library at library_path\n\n    Args:\n        library_path: str or pathlib.Path, path to new library\n\n    Returns: PhotoLibrary object for new library\n\n    Raises:\n        FileExistsError if library already exists at library_path\n        PhotoKitCreateLibraryError if unable to create library\n\n    Note:\n        This only works in multi-library mode; multi-library mode will be enabled if not already enabled.\n        This may file (after a long timeout) if a library with same name was recently created\n        (even if it has since been deleted).\n    \"\"\"\n    library_path = (\n        str(library_path) if not isinstance(library_path, str) else library_path\n    )\n    if pathlib.Path(library_path).is_dir():\n        raise FileExistsError(f\"Library already exists at {library_path}\")\n\n    # This only works in multi-library mode\n    PhotoLibrary.enable_multi_library_mode()\n\n    # Sometimes this can generate error messages to stderr regarding CoreData XPC errors\n    # I have not yet figured out what causes this\n    # Suppress the errors with pipes() and raise error when it times out\n    # Error appears to occur if a library with same name was recently created (even if it has since been deleted)\n    with pipes() as (out, err):\n        photo_library = Photos.PHPhotoLibrary.alloc().initWithPhotoLibraryURL_type_(\n            NSURL.fileURLWithPath_(library_path), 0\n        )\n        if photo_library.createPhotoLibraryUsingOptions_error_(None, None):\n            return PhotoLibrary(library_path)\n        else:\n            raise PhotoKitCreateLibraryError(\n                f\"Unable to create library at {library_path}\"\n            )\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.delete_album","title":"<code>delete_album(album)</code>","text":"<p>Delete album in the library</p> <p>Parameters:</p> Name Type Description Default <code>album</code> <code>Album</code> <p>Album object to delete</p> required Source code in <code>photokit/photolibrary.py</code> <pre><code>def delete_album(self, album: Album):\n\"\"\"Delete album in the library\n\n    Args:\n        album: Album object to delete\n\n    Raises:\n        PhotoKitAlbumDeleteError if unable to create album\n    \"\"\"\n\n    with objc.autorelease_pool():\n        event = threading.Event()\n\n        def completion_handler(success, error):\n            if error:\n                raise PhotoKitAlbumDeleteError(\n                    f\"Error deleting album {album}: {error}\"\n                )\n            event.set()\n\n        def delete_album_handler(album):\n            deletion_request = (\n                Photos.PHAssetCollectionChangeRequest.deleteAssetCollections_(\n                    [album.collection]\n                )\n            )\n\n        self._phphotolibrary.performChanges_completionHandler_(\n            lambda: delete_album_handler(album), completion_handler\n        )\n\n        event.wait()\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.delete_assets","title":"<code>delete_assets(photoassets)</code>","text":"<p>Delete assets.</p> <p>Parameters:</p> Name Type Description Default <code>photoassets</code> <code>list[PhotoAsset]</code> <p>list of PhotoAsset objects to delete</p> required <p>Note that this will prompt the user to confirm deletion of assets.</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def delete_assets(self, photoassets: list[PhotoAsset]):\n\"\"\"Delete assets.\n\n    Args:\n        photoassets: list of PhotoAsset objects to delete\n    Note that this will prompt the user to confirm deletion of assets.\n    \"\"\"\n    with objc.autorelease_pool():\n        assets = [asset.phasset for asset in photoassets]\n        self._phphotolibrary.performChangesAndWait_error_(\n            lambda: Photos.PHAssetChangeRequest.deleteAssets_(assets), None\n        )\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.enable_multi_library_mode","title":"<code>enable_multi_library_mode()</code>  <code>staticmethod</code>","text":"<p>Enable multi-library mode.  This is a no-op if already enabled.</p> Note <p>Some PhotoKit APIs only work in multi-library mode. Once enabled, it cannot be disabled and only single-library mode APIs will work. In practice, you should not need to use this and PhotoLibrary will manage this automatically.</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>@staticmethod\ndef enable_multi_library_mode():\n\"\"\"Enable multi-library mode.  This is a no-op if already enabled.\n\n    Note:\n        Some PhotoKit APIs only work in multi-library mode.\n        Once enabled, it cannot be disabled and only single-library mode APIs will work.\n        In practice, you should not need to use this and PhotoLibrary will manage this automatically.\n    \"\"\"\n    Photos.PHPhotoLibrary.enableMultiLibraryMode()\n    global _global_single_library_mode\n    _global_single_library_mode = False\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.fetch_burst_uuid","title":"<code>fetch_burst_uuid(burstid, all=False)</code>","text":"<p>fetch PhotoAssets with burst ID = burstid</p> <p>Parameters:</p> Name Type Description Default <code>burstid</code> <p>str, burst UUID</p> required <code>all</code> <p>return all burst assets; if False returns only those selected by the user (including the \"key photo\" even if user hasn't manually selected it)</p> <code>False</code> <p>Returns:</p> Type Description <p>list of PhotoAsset objects</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def fetch_burst_uuid(self, burstid, all=False):\n\"\"\"fetch PhotoAssets with burst ID = burstid\n\n    Args:\n        burstid: str, burst UUID\n        all: return all burst assets; if False returns only those selected by the user (including the \"key photo\" even if user hasn't manually selected it)\n\n    Returns:\n        list of PhotoAsset objects\n\n    Raises:\n        PhotoKitFetchFailed if fetch failed\n    \"\"\"\n\n    fetch_options = Photos.PHFetchOptions.alloc().init()\n    fetch_options.setIncludeAllBurstAssets_(all)\n    fetch_results = Photos.PHAsset.fetchAssetsWithBurstIdentifier_options_(\n        burstid, fetch_options\n    )\n    if fetch_results and fetch_results.count() &gt;= 1:\n        return [\n            self._asset_factory(fetch_results.objectAtIndex_(idx))\n            for idx in range(fetch_results.count())\n        ]\n    else:\n        raise PhotoKitFetchFailed(\n            f\"Fetch did not return result for burstid {burstid}\"\n        )\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.folders","title":"<code>folders()</code>","text":"<p>\"Return list of folders in the library</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def folders(self):\n\"\"\" \"Return list of folders in the library\"\"\"\n    with objc.autorelease_pool():\n        # these are single library mode only\n        # this gets all user albums\n        # albums = (\n        #     Photos.PHAssetCollection.fetchAssetCollectionsWithType_subtype_options_(\n        #         Photos.PHAssetCollectionTypeAlbum,\n        #         Photos.PHAssetCollectionSubtypeAny,\n        #         None,\n        #     )\n        # )\n        #\n        # this gets top level albums but also folders (PHCollectionList)\n        folders = (\n            Photos.PHCollectionList.fetchCollectionListsWithType_subtype_options_(\n                Photos.PHCollectionListTypeFolder,\n                Photos.PHCollectionListSubtypeAny,\n                None,\n            )\n        )\n        for i in range(folders.count()):\n            folder = folders.objectAtIndex_(i)\n            print(folder)\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.library_path","title":"<code>library_path()</code>","text":"<p>Return path to Photos library</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def library_path(self) -&gt; str:\n\"\"\"Return path to Photos library\"\"\"\n    return NSURL_to_path(self._phphotolibrary.photoLibraryURL())\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.multi_library_mode","title":"<code>multi_library_mode()</code>  <code>staticmethod</code>","text":"<p>Return True if multi-library mode is enabled, False otherwise</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>@staticmethod\ndef multi_library_mode() -&gt; bool:\n\"\"\"Return True if multi-library mode is enabled, False otherwise\"\"\"\n    return not _global_single_library_mode\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.observe_changes","title":"<code>observe_changes(callback)</code>","text":"<p>Observe changes to the library and call callback when changes occur</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def observe_changes(self, callback: Callable[[AssetChanges], None]):\n\"\"\"Observe changes to the library and call callback when changes occur\"\"\"\n    if PhotoLibrary.multi_library_mode():\n        raise NotImplementedError(\n            \"Observing changes not implemented in multi-library mode\"\n        )\n    with objc.autorelease_pool():\n        self._callback = callback\n        options = Photos.PHFetchOptions.alloc().init()\n        self._observed_assets = Photos.PHAsset.fetchAssetsWithOptions_(options)\n        # ZZZ need a way to fetch assets from the screenshot collection\n        # fetchAssetsInAssetCollection:options:\n        # and pass in the fetch to observe_changes\n    self._phphotolibrary.registerChangeObserver_(self)\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.photoLibraryDidChange_","title":"<code>photoLibraryDidChange_(change_instance)</code>","text":"<p>Handle a change to the Photo library</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def photoLibraryDidChange_(self, change_instance):\n\"\"\"Handle a change to the Photo library\"\"\"\n    if not self._callback:\n        raise PhotoKitError(\"No callback registered for change observer\")\n    if not callable(self._callback):\n        raise PhotoKitError(\"Callback is not callable\")\n\n    if not change_instance:\n        return\n\n    with objc.autorelease_pool():\n        change_details = change_instance.changeDetailsForFetchResult_(\n            self._observed_assets\n        )\n        if change_details:\n            if change_details.hasIncrementalChanges() and (\n                change_details.insertedObjects().count() &gt; 0\n                or change_details.removedObjects().count() &gt; 0\n                or change_details.changedObjects().count() &gt; 0\n            ):\n                added = [\n                    self._asset_factory(\n                        change_details.insertedObjects().objectAtIndex_(i)\n                    )\n                    for i in range(change_details.insertedObjects().count())\n                ]\n                removed = [\n                    self._asset_factory(\n                        change_details.removedObjects().objectAtIndex_(i)\n                    )\n                    for i in range(change_details.removedObjects().count())\n                ]\n                updated = [\n                    self._asset_factory(\n                        change_details.changedObjects().objectAtIndex_(i)\n                    )\n                    for i in range(change_details.changedObjects().count())\n                ]\n                self._callback(AssetChanges(added, removed, updated))\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.request_authorization","title":"<code>request_authorization(access_level=PHAccessLevelReadWrite)</code>  <code>staticmethod</code>","text":"<p>Request authorization to user's Photos Library</p> <p>Parameters:</p> Name Type Description Default <code>access_level</code> <code>int</code> <p>(int) PHAccessLevelAddOnly or PHAccessLevelReadWrite</p> <code>PHAccessLevelReadWrite</code> <p>Returns: True if authorization granted, False otherwise</p> In actual practice, the terminal process running the python code <p>will do the actual request. This method exists for use in bundled apps created with py2app, etc.  It has not yet been well tested.</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>@staticmethod\ndef request_authorization(\n    access_level: int = PHAccessLevelReadWrite,\n):\n\"\"\"Request authorization to user's Photos Library\n\n    Args:\n        access_level: (int) PHAccessLevelAddOnly or PHAccessLevelReadWrite\n\n    Returns: True if authorization granted, False otherwise\n\n    Note: In actual practice, the terminal process running the python code\n        will do the actual request. This method exists for use in bundled apps\n        created with py2app, etc.  It has not yet been well tested.\n    \"\"\"\n\n    def handler(status):\n        pass\n\n    read_write, add_only = PhotoLibrary.authorization_status()\n    if (\n        access_level == PHAccessLevelReadWrite\n        and read_write\n        or access_level == PHAccessLevelAddOnly\n        and add_only\n    ):\n        # already have access\n        return True\n\n    (ver, major, _) = get_macos_version()\n    if (int(ver), int(major)) &lt; (10, 16):\n        # it seems the first try fails after Terminal prompts user for access so try again\n        for _ in range(2):\n            Photos.PHPhotoLibrary.requestAuthorization_(handler)\n            auth_status = Photos.PHPhotoLibrary.authorizationStatus()\n            if auth_status == Photos.PHAuthorizationStatusAuthorized:\n                break\n        return bool(auth_status)\n\n    # requestAuthorization deprecated in 10.16/11.0\n    # use requestAuthorizationForAccessLevel instead\n    for _ in range(2):\n        auth_status = (\n            Photos.PHPhotoLibrary.requestAuthorizationForAccessLevel_handler_(\n                access_level, handler\n            )\n        )\n        read_write, add_only = PhotoLibrary.authorization_status()\n        if (\n            access_level == PHAccessLevelReadWrite\n            and read_write\n            or access_level == PHAccessLevelAddOnly\n            and add_only\n        ):\n            return True\n    return bool(auth_status)\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.selection","title":"<code>selection()</code>","text":"<p>Return list of assets currently selected in Photos app</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def selection(self) -&gt; list[Asset]:\n\"\"\"Return list of assets currently selected in Photos app\"\"\"\n    if selected_uuids := get_selected_uuids():\n        return self.assets(selected_uuids)\n    return []\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.smart_album","title":"<code>smart_album(album_name=None, album_type=None, user=False)</code>","text":"<p>Get smart album with given name</p> <p>Parameters:</p> Name Type Description Default <code>album_name</code> <code>str | None</code> <p>name of smart album to fetch</p> <code>None</code> <code>album_type</code> <code>PhotoLibrarySmartAlbumType | None</code> <p>PhotoLibrarySmartAlbumType of smart album to fetch</p> <code>None</code> <code>user</code> <code>bool</code> <p>if True, fetch user smart album instead of system smart album</p> <code>False</code> <p>Returns: Album object for smart album</p> <p>Note: This only works in single library mode. If more than one album has the same name, the first one found will be returned but no guarantee is made as to which one.</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def smart_album(\n    self,\n    album_name: str | None = None,\n    album_type: PhotoLibrarySmartAlbumType | None = None,\n    user: bool = False,\n) -&gt; Album:\n\"\"\"Get smart album with given name\n\n    Args:\n        album_name: name of smart album to fetch\n        album_type: PhotoLibrarySmartAlbumType of smart album to fetch\n        user: if True, fetch user smart album instead of system smart album\n\n    Returns: Album object for smart album\n\n    Raises:\n        PhotoKitFetchFailed if fetch failed (album not found)\n        ValueError if both album_name and album_type are None or both are not None\n\n    Note: This only works in single library mode. If more than one album has the same name,\n    the first one found will be returned but no guarantee is made as to which one.\n    \"\"\"\n\n    if PhotoLibrary.multi_library_mode():\n        raise NotImplementedError(\n            \"Fetching smart albums not implemented in multi-library mode\"\n        )\n\n    if (album_name and album_type) or (not album_name and not album_type):\n        raise ValueError(\n            f\"Must pass one of album_name or album_type: {album_name=}, {album_type=}\"\n        )\n\n    # single library mode\n    subtype = album_type.value if album_type else 0\n    with objc.autorelease_pool():\n        options = Photos.PHFetchOptions.alloc().init()\n        if user:\n            options.setIncludeUserSmartAlbums_(True)\n        albums = (\n            Photos.PHAssetCollection.fetchAssetCollectionsWithType_subtype_options_(\n                Photos.PHAssetCollectionTypeSmartAlbum,\n                subtype,\n                options,\n            )\n        )\n\n        # album type\n        if album_type:\n            if not albums.count():\n                raise PhotoKitFetchFailed(\n                    f\"Fetch did not return result for album_type {album_type}\"\n                )\n            return Album(self, albums.objectAtIndex_(0))\n\n        # album name\n        for i in range(albums.count()):\n            album = albums.objectAtIndex_(i)\n            if album.localizedTitle() == album_name and (\n                not user or album.isUserSmartAlbum()\n            ):\n                return Album(self, album)\n        raise PhotoKitFetchFailed(\n            f\"Fetch did not return result for album {album_name}\"\n        )\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.smart_albums","title":"<code>smart_albums(user=False)</code>","text":"<p>Get list of smart albums</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>bool</code> <p>if True, fetch user smart albums instead of system smart albums</p> <code>False</code> <p>Returns: list of Album objects for smart albums</p> <p>Note: This only works in single library mode</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def smart_albums(self, user: bool = False) -&gt; list[Album]:\n\"\"\"Get list of smart albums\n\n    Args:\n        user: if True, fetch user smart albums instead of system smart albums\n\n    Returns: list of Album objects for smart albums\n\n    Raises:\n        PhotoKitFetchFailed if fetch failed (album not found)\n\n    Note: This only works in single library mode\n    \"\"\"\n\n    if PhotoLibrary.multi_library_mode():\n        raise NotImplementedError(\n            \"Fetching smart albums not implemented in multi-library mode\"\n        )\n\n    # single library mode\n    subtype = 0\n    with objc.autorelease_pool():\n        options = Photos.PHFetchOptions.alloc().init()\n        if user:\n            options.setIncludeUserSmartAlbums_(True)\n        albums = (\n            Photos.PHAssetCollection.fetchAssetCollectionsWithType_subtype_options_(\n                Photos.PHAssetCollectionTypeSmartAlbum,\n                subtype,\n                options,\n            )\n        )\n\n        album_list = []\n        for i in range(albums.count()):\n            album = albums.objectAtIndex_(i)\n            if user and not album.isUserSmartAlbum():\n                continue\n            elif not user and album.isUserSmartAlbum():\n                continue\n            album_list.append(Album(self, album))\n\n        if not album_list:\n            raise PhotoKitFetchFailed(\n                f\"Fetch did not return result for smart albums\"\n            )\n\n        return album_list\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.stop_observing_changes","title":"<code>stop_observing_changes()</code>","text":"<p>Stop observing changes to the library</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>def stop_observing_changes(self):\n\"\"\"Stop observing changes to the library\"\"\"\n    if self._callback:\n        self._phphotolibrary.unregisterChangeObserver_(self)\n</code></pre>"},{"location":"reference/#photokit.PhotoLibrary.system_photo_library_path","title":"<code>system_photo_library_path()</code>  <code>staticmethod</code>","text":"<p>Return path to system photo library</p> Source code in <code>photokit/photolibrary.py</code> <pre><code>@staticmethod\ndef system_photo_library_path() -&gt; str:\n\"\"\"Return path to system photo library\"\"\"\n    return NSURL_to_path(Photos.PHPhotoLibrary.systemPhotoLibraryURL())\n</code></pre>"},{"location":"reference/#photolibrarysmartalbumtype","title":"PhotoLibrarySmartAlbumType","text":"<p>             Bases: <code>Enum</code></p> <p>Smart album types.  The following are supported:</p> <ul> <li>Favorites</li> <li>Hidden</li> <li>Animated</li> <li>Bursts</li> <li>Cinematics</li> <li>Portraits</li> <li>Generic</li> <li>LivePhotos</li> <li>LongExposures</li> <li>Panoramas</li> <li>RAW</li> <li>RecentlyAdded</li> <li>Screenshots</li> <li>Selfies</li> <li>SlowMos</li> <li>TimeLapses</li> <li>UnableToUload</li> <li>UserLibrary</li> <li>Videos</li> </ul> Source code in <code>photokit/photolibrary.py</code> <pre><code>class PhotoLibrarySmartAlbumType(enum.Enum):\n\"\"\"Smart album types.  The following are supported:\n\n    - Favorites\n    - Hidden\n    - Animated\n    - Bursts\n    - Cinematics\n    - Portraits\n    - Generic\n    - LivePhotos\n    - LongExposures\n    - Panoramas\n    - RAW\n    - RecentlyAdded\n    - Screenshots\n    - Selfies\n    - SlowMos\n    - TimeLapses\n    - UnableToUload\n    - UserLibrary\n    - Videos\n    \"\"\"\n\n    # reference: https://developer.apple.com/documentation/photokit/phassetcollectionsubtype?language=objc\n    Favorites = Photos.PHAssetCollectionSubtypeSmartAlbumFavorites\n    Hidden = Photos.PHAssetCollectionSubtypeSmartAlbumAllHidden\n    Animated = Photos.PHAssetCollectionSubtypeSmartAlbumAnimated\n    Bursts = Photos.PHAssetCollectionSubtypeSmartAlbumBursts\n    Cinematics = Photos.PHAssetCollectionSubtypeSmartAlbumCinematic\n    Portraits = Photos.PHAssetCollectionSubtypeSmartAlbumDepthEffect\n    Generic = Photos.PHAssetCollectionSubtypeSmartAlbumGeneric\n    LivePhotos = Photos.PHAssetCollectionSubtypeSmartAlbumLivePhotos\n    LongExposures = Photos.PHAssetCollectionSubtypeSmartAlbumLongExposures\n    Panoramas = Photos.PHAssetCollectionSubtypeSmartAlbumPanoramas\n    RAW = Photos.PHAssetCollectionSubtypeSmartAlbumRAW\n    RecentlyAdded = Photos.PHAssetCollectionSubtypeSmartAlbumRecentlyAdded\n    Screenshots = Photos.PHAssetCollectionSubtypeSmartAlbumScreenshots\n    Selfies = Photos.PHAssetCollectionSubtypeSmartAlbumSelfPortraits\n    SlowMos = Photos.PHAssetCollectionSubtypeSmartAlbumSlomoVideos\n    TimeLapses = Photos.PHAssetCollectionSubtypeSmartAlbumTimelapses\n    UnableToUload = Photos.PHAssetCollectionSubtypeSmartAlbumUnableToUpload\n    UserLibrary = Photos.PHAssetCollectionSubtypeSmartAlbumUserLibrary\n    Videos = Photos.PHAssetCollectionSubtypeSmartAlbumVideos\n</code></pre>"},{"location":"reference/#photoasset","title":"PhotoAsset","text":"<p>             Bases: <code>Asset</code></p> <p>PhotoKit PHAsset representation</p> Source code in <code>photokit/asset.py</code> <pre><code>class PhotoAsset(Asset):\n\"\"\"PhotoKit PHAsset representation\"\"\"\n\n    def __init__(self, library: PhotoLibrary, phasset: Photos.PHAsset):\n\"\"\"Return a PhotoAsset object\n\n        Args:\n            library: a PhotoLibrary object\n            phasset: a PHAsset object\n        \"\"\"\n        self._library = library\n        self._manager = self._library._phimagemanager\n        self._phasset = phasset\n\n    @property\n    def phasset(self):\n\"\"\"Return PHAsset instance\"\"\"\n        return self._phasset\n\n    @property\n    def uuid(self):\n\"\"\"Return UUID of PHAsset. This is the same as the local identifier minus the added path component.\"\"\"\n        return self._phasset.localIdentifier().split(\"/\")[0]\n\n    @property\n    def local_identifier(self):\n\"\"\"Return local identifier of PHAsset\"\"\"\n        return self._phasset.localIdentifier()\n\n    @property\n    def isphoto(self):\n\"\"\"Return True if asset is photo (image), otherwise False\"\"\"\n        return self.media_type == Photos.PHAssetMediaTypeImage\n\n    @property\n    def ismovie(self):\n\"\"\"Return True if asset is movie (video), otherwise False\"\"\"\n        return self.media_type == Photos.PHAssetMediaTypeVideo\n\n    @property\n    def isaudio(self):\n\"\"\"Return True if asset is audio, otherwise False\"\"\"\n        return self.media_type == Photos.PHAssetMediaTypeAudio\n\n    @property\n    def original_filename(self):\n\"\"\"Return original filename asset was imported with\"\"\"\n        resources = self._resources()\n        for resource in resources:\n            if (\n                self.isphoto\n                and resource.type() == Photos.PHAssetResourceTypePhoto\n                or not self.isphoto\n                and resource.type() == Photos.PHAssetResourceTypeVideo\n            ):\n                return resource.originalFilename()\n        raise PhotoKitFetchFailed(\"Could not find original filename\")\n\n    @property\n    def raw_filename(self):\n\"\"\"Return RAW filename for RAW+JPEG photos or None if no RAW asset\"\"\"\n        resources = self._resources()\n        for resource in resources:\n            if (\n                self.isphoto\n                and resource.type() == Photos.PHAssetResourceTypeAlternatePhoto\n            ):\n                return resource.originalFilename()\n        return None\n\n    @property\n    def hasadjustments(self):\n\"\"\"Check to see if a PHAsset has adjustment data associated with it\n        Returns False if no adjustments, True if any adjustments\"\"\"\n\n        # reference: https://developer.apple.com/documentation/photokit/phassetresource/1623988-assetresourcesforasset?language=objc\n\n        adjustment_resources = Photos.PHAssetResource.assetResourcesForAsset_(\n            self.phasset\n        )\n        return any(\n            (\n                adjustment_resources.objectAtIndex_(idx).type()\n                == Photos.PHAssetResourceTypeAdjustmentData\n            )\n            for idx in range(adjustment_resources.count())\n        )\n\n    @property\n    def media_type(self):\n\"\"\"media type such as image or video\"\"\"\n        return self.phasset.mediaType()\n\n    @property\n    def media_subtypes(self):\n\"\"\"media subtype\"\"\"\n        return self.phasset.mediaSubtypes()\n\n    @property\n    def panorama(self):\n\"\"\"return True if asset is panorama, otherwise False\"\"\"\n        return bool(self.media_subtypes &amp; Photos.PHAssetMediaSubtypePhotoPanorama)\n\n    @property\n    def hdr(self):\n\"\"\"return True if asset is HDR, otherwise False\"\"\"\n        return bool(self.media_subtypes &amp; Photos.PHAssetMediaSubtypePhotoHDR)\n\n    @property\n    def screenshot(self):\n\"\"\"return True if asset is screenshot, otherwise False\"\"\"\n        return bool(self.media_subtypes &amp; Photos.PHAssetMediaSubtypePhotoScreenshot)\n\n    @property\n    def live(self):\n\"\"\"return True if asset is live, otherwise False\"\"\"\n        return bool(self.media_subtypes &amp; Photos.PHAssetMediaSubtypePhotoLive)\n\n    @property\n    def streamed(self):\n\"\"\"return True if asset is streamed video, otherwise False\"\"\"\n        return bool(self.media_subtypes &amp; Photos.PHAssetMediaSubtypeVideoStreamed)\n\n    @property\n    def slow_mo(self):\n\"\"\"return True if asset is slow motion (high frame rate) video, otherwise False\"\"\"\n        return bool(self.media_subtypes &amp; Photos.PHAssetMediaSubtypeVideoHighFrameRate)\n\n    @property\n    def time_lapse(self):\n\"\"\"return True if asset is time lapse video, otherwise False\"\"\"\n        return bool(self.media_subtypes &amp; Photos.PHAssetMediaSubtypeVideoTimelapse)\n\n    @property\n    def portrait(self):\n\"\"\"return True if asset is portrait (depth effect), otherwise False\"\"\"\n        return bool(self.media_subtypes &amp; Photos.PHAssetMediaSubtypePhotoDepthEffect)\n\n    @property\n    def burstid(self):\n\"\"\"return burstIdentifier of image if image is burst photo otherwise None\"\"\"\n        return self.phasset.burstIdentifier()\n\n    @property\n    def burst(self):\n\"\"\"return True if image is burst otherwise False\"\"\"\n        return bool(self.burstid)\n\n    @property\n    def source_type(self):\n\"\"\"the means by which the asset entered the user's library\"\"\"\n        return self.phasset.sourceType()\n\n    @property\n    def pixel_width(self):\n\"\"\"width in pixels\"\"\"\n        return self.phasset.pixelWidth()\n\n    @property\n    def pixel_height(self):\n\"\"\"height in pixels\"\"\"\n        return self.phasset.pixelHeight()\n\n    @property\n    def date(self) -&gt; datetime.datetime:\n\"\"\"date asset was created as a naive datetime.datetime\"\"\"\n        return NSDate_to_datetime(self.phasset.creationDate())\n\n    @date.setter\n    def date(self, date: datetime.datetime):\n\"\"\"Set date asset was created\"\"\"\n\n        def change_request_handler(change_request: Photos.PHAssetChangeRequest):\n            creation_date = datetime_to_NSDate(date)\n            change_request.setCreationDate_(creation_date)\n\n        self._perform_changes(change_request_handler)\n\n    @property\n    def date_modified(self) -&gt; datetime.datetime:\n\"\"\"date asset was modified as a naive datetime.datetime\"\"\"\n        return NSDate_to_datetime(self.phasset.modificationDate())\n\n    @date_modified.setter\n    def date_modified(self, date: datetime.datetime):\n\"\"\"Set date asset was modified\"\"\"\n\n        def change_request_handler(change_request: Photos.PHAssetChangeRequest):\n            modification_date = datetime_to_NSDate(date)\n            change_request.setModificationDate_(modification_date)\n\n        self._perform_changes(change_request_handler)\n\n    @property\n    def date_added(self) -&gt; datetime.datetime:\n\"\"\"date asset was added to the library as a naive datetime.datetime\"\"\"\n        # as best as I can tell there is no property to retrieve the date added\n        # so get it from the database\n        return self._library._photosdb.get_date_added_for_uuid(self.uuid)\n\n    @date_added.setter\n    def date_added(self, date: datetime.datetime):\n\"\"\"Set date asset was added to the library\"\"\"\n\n        def change_request_handler(change_request: Photos.PHAssetChangeRequest):\n            added_date = datetime_to_NSDate(date)\n            change_request.setAddedDate_(added_date)\n\n        self._perform_changes(change_request_handler)\n\n    @property\n    def timezone_offset(self) -&gt; int:\n\"\"\"Timezone offset (seconds from GMT) of the asset\"\"\"\n        # no property that I can find to retrieve this directly\n        # so query the database instead\n        return self._library._photosdb.get_timezone_for_uuid(self.uuid)[0]\n\n    @timezone_offset.setter\n    def timezone_offset(self, tz_offset: int):\n\"\"\"Set timezone offset from UTC (in seconds) for asset\"\"\"\n\n        def change_request_handler(change_request: Photos.PHAssetChangeRequest):\n            timezone = Foundation.NSTimeZone.timeZoneForSecondsFromGMT_(tz_offset)\n            date = change_request.creationDate()\n            change_request.setTimeZone_withDate_(timezone, date)\n\n        self._perform_changes(change_request_handler)\n\n    @property\n    def timezone(self) -&gt; str:\n\"\"\"The named timezone of the asset\"\"\"\n        return self._library._photosdb.get_timezone_for_uuid(self.uuid)[2]\n\n    @timezone.setter\n    def timezone(self, tz: str):\n\"\"\"Set the named timzone of the asset\"\"\"\n\n        with objc.autorelease_pool():\n            timezone = Foundation.NSTimeZone.timeZoneWithName_(tz)\n            if not timezone:\n                raise ValueError(f\"Invalid timezone: {tz}\")\n\n            def change_request_handler(change_request: Photos.PHAssetChangeRequest):\n                date = change_request.creationDate()\n                change_request.setTimeZone_withDate_(timezone, date)\n\n            self._perform_changes(change_request_handler)\n\n    @property\n    def location(self) -&gt; tuple[float, float] | None:\n\"\"\"location of the asset as a tuple of (latitude, longitude) or None if no location\"\"\"\n        self._refresh()\n        cllocation = self.phasset.location()\n        return cllocation.coordinate() if cllocation else None\n\n    @location.setter\n    def location(self, latlon: tuple[float, float] | None):\n\"\"\"Set location of asset to lat, lon or None\"\"\"\n\n        with objc.autorelease_pool():\n\n            def change_request_handler(change_request: Photos.PHAssetChangeRequest):\n                if latlon is None:\n                    location = Foundation.CLLocation.alloc().init()\n                else:\n                    location = (\n                        Foundation.CLLocation.alloc().initWithLatitude_longitude_(\n                            latlon[0], latlon[1]\n                        )\n                    )\n                change_request.setLocation_(location)\n\n            self._perform_changes(change_request_handler)\n\n    @property\n    def duration(self) -&gt; float:\n\"\"\"duration of the asset in seconds\"\"\"\n        return self.phasset.duration()\n\n    @property\n    def favorite(self) -&gt; bool:\n\"\"\"True if asset is favorite, otherwise False\"\"\"\n        self._refresh()\n        return self.phasset.isFavorite()\n\n    @favorite.setter\n    def favorite(self, value: bool):\n\"\"\"Set or clear favorite status of asset\"\"\"\n\n        def change_request_handler(change_request: Photos.PHAssetChangeRequest):\n            change_request.setFavorite_(value)\n\n        self._perform_changes(change_request_handler)\n\n    @property\n    def hidden(self):\n\"\"\"True if asset is hidden, otherwise False\"\"\"\n        self._refresh()\n        return self.phasset.isHidden()\n\n    @hidden.setter\n    def hidden(self, value: bool):\n\"\"\"Set or clear hidden status of asset; note that toggling hidden may requre user confirmation\"\"\"\n\n        def change_request_handler(change_request: Photos.PHAssetChangeRequest):\n            change_request.setHidden_(value)\n\n        self._perform_changes(change_request_handler, refresh=False)\n\n    @property\n    def keywords(self) -&gt; list[str]:\n\"\"\"Keywords associated with asset\"\"\"\n        self._refresh()\n        keywords = Photos.PHKeyword.fetchKeywordsForAsset_options_(self.phasset, None)\n        return [keywords.objectAtIndex_(idx).title() for idx in range(keywords.count())]\n\n    @keywords.setter\n    def keywords(self, keywords: list[str]):\n\"\"\"Set keywords associated with asset\"\"\"\n        with objc.autorelease_pool():\n            # get PHKeyword objects for current keywords\n            current_phkeywords = self._library._keywords_from_title_list(self.keywords)\n\n            # get PHKeyword objects for new keywords\n            try:\n                new_phkeywords = self._library._keywords_from_title_list(keywords)\n            except PhotoKitFetchFailed:\n                new_phkeywords = []\n            phkeywords_titles = [kw.title() for kw in new_phkeywords]\n\n            # are there any new keywords that need to be created?\n            new_keywords = [kw for kw in keywords if kw not in phkeywords_titles]\n            for kw in new_keywords:\n                new_phkeywords.append(self._library.create_keyword(kw))\n\n            phkeywords_to_remove = [\n                kw for kw in current_phkeywords if kw not in new_phkeywords\n            ]\n\n            def change_request_handler(change_request: Photos.PHAssetChangeRequest):\n                change_request.addKeywords_(new_phkeywords)\n                if phkeywords_to_remove:\n                    change_request.removeKeywords_(phkeywords_to_remove)\n\n            self._perform_changes(change_request_handler)\n\n    @property\n    def title(self) -&gt; str:\n\"\"\"Return title of asset\"\"\"\n        self._refresh()\n        return self.phasset.title()\n\n    @title.setter\n    def title(self, value: str | None):\n\"\"\"Set the title of the asset\"\"\"\n\n        value = value or \"\"\n\n        def change_request_handler(change_request: Photos.PHAssetChangeRequest):\n            change_request.setTitle_(value)\n\n        self._perform_changes(change_request_handler, refresh=False)\n\n    @property\n    def accessibility_description(self) -&gt; str:\n\"\"\"Get the accessibilty description of the asset\"\"\"\n        self._refresh()\n        return self.phasset.descriptionProperties().accessibilityDescription()\n\n    @property\n    def description(self) -&gt; str:\n\"\"\"Get the description of the asset\"\"\"\n        self._refresh()\n        return self.phasset.descriptionProperties().assetDescription()\n\n    @description.setter\n    def description(self, value: str | None) -&gt; None:\n\"\"\"Set the description of the asset; requires use of ScriptingBridge so this only works on the default library\"\"\"\n        # Implementation Note:\n        # I would like to use PhotoKit to set the asset description and there is a PHChangeRequest.setAssetDescription method\n        # but this fails to set the description. I have spent about 20 hours attempting to reverse engineer this\n        # and have given up for now\n        # Attempting to set the asset description in a change block does not raise an error but fails\n        # to change the description\n        # Unlike all other attributes, the description has validateAssetDescription_error_ and setAssetDescriptionWasSet_\n        # methods implying that setting the description is more involved than other attributes but I have not\n        # been able to successfully make these work\n        # For now, this uses ScriptingBridge to set the description which means it is only valid on the\n        # default (last opened) library\n        photo_set_description(self.uuid, value)\n\n    # Not working yet\n    # @property\n    # def persons(self) -&gt; list[str]:\n    #     \"\"\"Persons in the asset\"\"\"\n    #     persons = Photos.PHPerson.fetchPersonsInAsset_options_(self.phasset, None)\n    #     person_list = []\n    #     for idx in range(persons.count()):\n    #         print(persons.objectAtIndex_(idx))\n    #         person_list.append(persons.objectAtIndex_(idx).displayName())\n    #     return person_list\n\n    def metadata(self, version=PHImageRequestOptionsVersionCurrent):\n\"\"\"Return dict of asset metadata\n\n        Args:\n            version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n        \"\"\"\n        imagedata = self._request_image_data(version=version)\n        return imagedata.metadata\n\n    def uti(self, version=PHImageRequestOptionsVersionCurrent):\n\"\"\"Return UTI of asset\n\n        Args:\n            version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n        \"\"\"\n        imagedata = self._request_image_data(version=version)\n        return imagedata.uti\n\n    def uti_raw(self):\n\"\"\"Return UTI of RAW component of RAW+JPEG pair\"\"\"\n        resources = self._resources()\n        for resource in resources:\n            if (\n                self.isphoto\n                and resource.type() == Photos.PHAssetResourceTypeAlternatePhoto\n            ):\n                return resource.uniformTypeIdentifier()\n        return None\n\n    def url(self, version=PHImageRequestOptionsVersionCurrent):\n\"\"\"Return URL of asset\n\n        Args:\n            version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n        \"\"\"\n        imagedata = self._request_image_data(version=version)\n        return str(imagedata.info[\"PHImageFileURLKey\"])\n\n    def path(self, version=PHImageRequestOptionsVersionCurrent):\n\"\"\"Return path of asset\n\n        Args:\n            version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n        \"\"\"\n        imagedata = self._request_image_data(version=version)\n        url = imagedata.info[\"PHImageFileURLKey\"]\n        return url.fileSystemRepresentation().decode(\"utf-8\")\n\n    def orientation(self, version=PHImageRequestOptionsVersionCurrent):\n\"\"\"Return orientation of asset\n\n        Args:\n            version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n        \"\"\"\n        imagedata = self._request_image_data(version=version)\n        return imagedata.orientation\n\n    @property\n    def degraded(self, version=PHImageRequestOptionsVersionCurrent):\n\"\"\"Return True if asset is degraded version\n\n        Args:\n            version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n        \"\"\"\n        imagedata = self._request_image_data(version=version)\n        return imagedata.info[\"PHImageResultIsDegradedKey\"]\n\n    @property\n    def debug_description(self) -&gt; str:\n\"\"\"Return debug description for asset\"\"\"\n        return self.phasset.debugDescription()\n\n    @property\n    def debug_metadata_description(self) -&gt; str:\n\"\"\"Return metadata debug description for asset\"\"\"\n        return self.phasset.metadataDebugDescription()\n\n    @property\n    def debug_resources_description(self) -&gt; str:\n\"\"\"Return resourcesDebugDescription for asset\"\"\"\n        return self.phasset.resourcesDebugDescription()\n\n    def _refresh(self):\n\"\"\"Reload the asset from the library\"\"\"\n        # this shouldn't be necessary but sometimes after creating a change (for example, toggling favorite)\n        # the properties do not refresh\n        self._phasset = self._library.asset(self.uuid)._phasset\n\n    def _perform_changes(\n        self,\n        change_request_handler: Callable[[Photos.PHAssetChangeRequest], None],\n        refresh: bool = True,\n    ):\n\"\"\"Perform changes on a PHAsset\n\n        Args:\n            change_request_handler: a callable that will be passed the PHAssetChangeRequest to perform changes\n            refresh: if True, refresh the asset from the library after performing changes (default is True)\n        \"\"\"\n\n        with objc.autorelease_pool():\n\n            def _change_request_handler():\n                change_request = Photos.PHAssetChangeRequest.changeRequestForAsset_(\n                    self.phasset\n                )\n                change_request_handler(change_request)\n\n            error = self._library._phphotolibrary.performChangesAndWait_error_(\n                lambda: _change_request_handler(), None\n            )\n\n            if error:\n                PhotoKitChangeError(f\"Error changing asset: {error}\")\n\n            if refresh:\n                self._refresh()\n\n    # def _perform_changes(\n    #     self,\n    #     change_request_handler: Callable[[Photos.PHAssetChangeRequest], None],\n    #     refresh: bool = True,\n    # ):\n    #     \"\"\"Perform changes on a PHAsset\n\n    #     Args:\n    #         change_request_handler: a callable that will be passed the PHAssetChangeRequest to perform changes\n    #         refresh: if True, refresh the asset from the library after performing changes (default is True)\n    #     \"\"\"\n\n    #     with objc.autorelease_pool():\n    #         event = threading.Event()\n\n    #         def completion_handler(success, error):\n    #             if error:\n    #                 raise PhotoKitChangeError(f\"Error changing asset: {error}\")\n    #             event.set()\n\n    #         def _change_request_handler():\n    #             change_request = Photos.PHAssetChangeRequest.changeRequestForAsset_(\n    #                 self.phasset\n    #             )\n    #             change_request_handler(change_request)\n\n    #         self._library._phphotolibrary.performChanges_completionHandler_(\n    #             lambda: _change_request_handler(), completion_handler\n    #         )\n\n    #         event.wait()\n\n    #         if refresh:\n    #             self._refresh()\n\n    def export(\n        self,\n        dest,\n        filename=None,\n        version=PHImageRequestOptionsVersionCurrent,\n        overwrite=False,\n        raw=False,\n        **kwargs,\n    ):\n\"\"\"Export image to path\n\n        Args:\n            dest: str, path to destination directory\n            filename: str, optional name of exported file; if not provided, defaults to asset's original filename\n            version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n            overwrite: bool, if True, overwrites destination file if it already exists; default is False\n            raw: bool, if True, export RAW component of RAW+JPEG pair, default is False\n            **kwargs: used only to avoid issues with each asset type having slightly different export arguments\n\n        Returns:\n            List of path to exported image(s)\n\n        Raises:\n            ValueError if dest is not a valid directory\n        \"\"\"\n\n        with objc.autorelease_pool():\n            with pipes() as (out, err):\n                filename = (\n                    pathlib.Path(filename)\n                    if filename\n                    else pathlib.Path(self.original_filename)\n                )\n\n                dest = pathlib.Path(dest)\n                if not dest.is_dir():\n                    raise ValueError(\"dest must be a valid directory: {dest}\")\n\n                output_file = None\n                if self.isphoto:\n                    # will hold exported image data and needs to be cleaned up at end\n                    imagedata = None\n                    if raw:\n                        # export the raw component\n                        resources = self._resources()\n                        for resource in resources:\n                            if (\n                                resource.type()\n                                == Photos.PHAssetResourceTypeAlternatePhoto\n                            ):\n                                data = self._request_resource_data(resource)\n                                suffix = pathlib.Path(self.raw_filename).suffix\n                                ext = suffix[1:] if suffix else \"\"\n                                break\n                        else:\n                            raise PhotoKitExportError(\n                                \"Could not get image data for RAW photo\"\n                            )\n                    else:\n                        # TODO: if user has selected use RAW as original, this returns the RAW\n                        # can get the jpeg with resource.type() == Photos.PHAssetResourceTypePhoto\n                        imagedata = self._request_image_data(version=version)\n                        if not imagedata.image_data:\n                            raise PhotoKitExportError(\"Could not get image data\")\n                        ext = get_preferred_uti_extension(imagedata.uti)\n                        data = imagedata.image_data\n\n                    output_file = dest / f\"{filename.stem}.{ext}\"\n\n                    if not overwrite:\n                        output_file = pathlib.Path(increment_filename(output_file))\n\n                    with open(output_file, \"wb\") as fd:\n                        fd.write(data)\n\n                    if imagedata:\n                        del imagedata\n                elif self.ismovie:\n                    videodata = self._request_video_data(version=version)\n                    if videodata.asset is None:\n                        raise PhotoKitExportError(\"Could not get video for asset\")\n\n                    url = videodata.asset.URL()\n                    path = pathlib.Path(NSURL_to_path(url))\n                    if not path.is_file():\n                        raise FileNotFoundError(\"Could not get path to video file\")\n                    ext = path.suffix\n                    output_file = dest / f\"{filename.stem}{ext}\"\n\n                    if not overwrite:\n                        output_file = pathlib.Path(increment_filename(output_file))\n\n                    FileUtil.copy(path, output_file)\n\n                return [str(output_file)]\n\n    def _request_image_data(self, version=PHImageRequestOptionsVersionOriginal):\n\"\"\"Request image data and metadata for self._phasset\n\n        Args:\n            version: which version to request\n                     PHImageRequestOptionsVersionOriginal (default), request original highest fidelity version\n                     PHImageRequestOptionsVersionCurrent, request current version with all edits\n                     PHImageRequestOptionsVersionUnadjusted, request highest quality unadjusted version\n\n        Returns:\n            ImageData instance\n\n        Raises:\n            ValueError if passed invalid value for version\n        \"\"\"\n\n        # reference: https://developer.apple.com/documentation/photokit/phimagemanager/3237282-requestimagedataandorientationfo?language=objc\n\n        with objc.autorelease_pool():\n            if version not in [\n                PHImageRequestOptionsVersionCurrent,\n                PHImageRequestOptionsVersionOriginal,\n                PHImageRequestOptionsVersionUnadjusted,\n            ]:\n                raise ValueError(\"Invalid value for version\")\n\n            options_request = Photos.PHImageRequestOptions.alloc().init()\n            options_request.setNetworkAccessAllowed_(True)\n            options_request.setSynchronous_(True)\n            options_request.setVersion_(version)\n            options_request.setDeliveryMode_(\n                Photos.PHImageRequestOptionsDeliveryModeHighQualityFormat\n            )\n            requestdata = ImageData()\n            event = threading.Event()\n\n            def handler(imageData, dataUTI, orientation, info):\n\"\"\"result handler for requestImageDataAndOrientationForAsset_options_resultHandler_\n                all returned by the request is set as properties of nonlocal data (Fetchdata object)\n                \"\"\"\n\n                nonlocal requestdata\n\n                options = {Quartz.kCGImageSourceShouldCache: Foundation.kCFBooleanFalse}\n                imgSrc = Quartz.CGImageSourceCreateWithData(imageData, options)\n                requestdata.metadata = Quartz.CGImageSourceCopyPropertiesAtIndex(\n                    imgSrc, 0, options\n                )\n                requestdata.uti = dataUTI\n                requestdata.orientation = orientation\n                requestdata.info = info\n                requestdata.image_data = imageData\n\n                event.set()\n\n            self._manager.requestImageDataAndOrientationForAsset_options_resultHandler_(\n                self.phasset, options_request, handler\n            )\n            event.wait()\n            # options_request.dealloc()\n\n            # not sure why this is needed -- some weird ref count thing maybe\n            # if I don't do this, memory leaks\n            data = copy.copy(requestdata)\n            del requestdata\n            return data\n\n    def _request_resource_data(self, resource):\n\"\"\"Request asset resource data (either photo or video component)\n\n        Args:\n            resource: PHAssetResource to request\n\n        Raises:\n        \"\"\"\n\n        with objc.autorelease_pool():\n            resource_manager = Photos.PHAssetResourceManager.defaultManager()\n            options = Photos.PHAssetResourceRequestOptions.alloc().init()\n            options.setNetworkAccessAllowed_(True)\n\n            requestdata = PHAssetResourceData()\n            event = threading.Event()\n\n            def handler(data):\n\"\"\"result handler for requestImageDataAndOrientationForAsset_options_resultHandler_\n                all returned by the request is set as properties of nonlocal data (Fetchdata object)\n                \"\"\"\n\n                nonlocal requestdata\n\n                requestdata.data += data\n\n            def completion_handler(error):\n                if error:\n                    raise PhotoKitExportError(\n                        \"Error requesting data for asset resource\"\n                    )\n                event.set()\n\n            resource_manager.requestDataForAssetResource_options_dataReceivedHandler_completionHandler_(\n                resource, options, handler, completion_handler\n            )\n\n            event.wait()\n\n            # not sure why this is needed -- some weird ref count thing maybe\n            # if I don't do this, memory leaks\n            data = copy.copy(requestdata.data)\n            del requestdata\n            return data\n\n    def _make_result_handle_(self, data):\n\"\"\"Make handler function and threading event to use with\n        requestImageDataAndOrientationForAsset_options_resultHandler_\n        data: Fetchdata class to hold resulting metadata\n        returns: handler function, threading.Event() instance\n        Following call to requestImageDataAndOrientationForAsset_options_resultHandler_,\n        data will hold data from the fetch\"\"\"\n\n        event = threading.Event()\n\n        def handler(imageData, dataUTI, orientation, info):\n\"\"\"result handler for requestImageDataAndOrientationForAsset_options_resultHandler_\n            all returned by the request is set as properties of nonlocal data (Fetchdata object)\n            \"\"\"\n\n            nonlocal data\n\n            options = {Quartz.kCGImageSourceShouldCache: Foundation.kCFBooleanFalse}\n            imgSrc = Quartz.CGImageSourceCreateWithData(imageData, options)\n            data.metadata = Quartz.CGImageSourceCopyPropertiesAtIndex(\n                imgSrc, 0, options\n            )\n            data.uti = dataUTI\n            data.orientation = orientation\n            data.info = info\n            data.image_data = imageData\n\n            event.set()\n\n        return handler, event\n\n    def _resources(self):\n\"\"\"Return list of PHAssetResource for object\"\"\"\n        resources = Photos.PHAssetResource.assetResourcesForAsset_(self.phasset)\n        return [resources.objectAtIndex_(idx) for idx in range(resources.count())]\n</code></pre>"},{"location":"reference/#photokit.PhotoAsset.accessibility_description","title":"<code>accessibility_description: str</code>  <code>property</code>","text":"<p>Get the accessibilty description of the asset</p>"},{"location":"reference/#photokit.PhotoAsset.burst","title":"<code>burst</code>  <code>property</code>","text":"<p>return True if image is burst otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.burstid","title":"<code>burstid</code>  <code>property</code>","text":"<p>return burstIdentifier of image if image is burst photo otherwise None</p>"},{"location":"reference/#photokit.PhotoAsset.date","title":"<code>date: datetime.datetime</code>  <code>property</code> <code>writable</code>","text":"<p>date asset was created as a naive datetime.datetime</p>"},{"location":"reference/#photokit.PhotoAsset.date_added","title":"<code>date_added: datetime.datetime</code>  <code>property</code> <code>writable</code>","text":"<p>date asset was added to the library as a naive datetime.datetime</p>"},{"location":"reference/#photokit.PhotoAsset.date_modified","title":"<code>date_modified: datetime.datetime</code>  <code>property</code> <code>writable</code>","text":"<p>date asset was modified as a naive datetime.datetime</p>"},{"location":"reference/#photokit.PhotoAsset.debug_description","title":"<code>debug_description: str</code>  <code>property</code>","text":"<p>Return debug description for asset</p>"},{"location":"reference/#photokit.PhotoAsset.debug_metadata_description","title":"<code>debug_metadata_description: str</code>  <code>property</code>","text":"<p>Return metadata debug description for asset</p>"},{"location":"reference/#photokit.PhotoAsset.debug_resources_description","title":"<code>debug_resources_description: str</code>  <code>property</code>","text":"<p>Return resourcesDebugDescription for asset</p>"},{"location":"reference/#photokit.PhotoAsset.degraded","title":"<code>degraded</code>  <code>property</code>","text":"<p>Return True if asset is degraded version</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <p>which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)</p> required"},{"location":"reference/#photokit.PhotoAsset.description","title":"<code>description: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get the description of the asset</p>"},{"location":"reference/#photokit.PhotoAsset.duration","title":"<code>duration: float</code>  <code>property</code>","text":"<p>duration of the asset in seconds</p>"},{"location":"reference/#photokit.PhotoAsset.favorite","title":"<code>favorite: bool</code>  <code>property</code> <code>writable</code>","text":"<p>True if asset is favorite, otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.hasadjustments","title":"<code>hasadjustments</code>  <code>property</code>","text":"<p>Check to see if a PHAsset has adjustment data associated with it Returns False if no adjustments, True if any adjustments</p>"},{"location":"reference/#photokit.PhotoAsset.hdr","title":"<code>hdr</code>  <code>property</code>","text":"<p>return True if asset is HDR, otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.hidden","title":"<code>hidden</code>  <code>property</code> <code>writable</code>","text":"<p>True if asset is hidden, otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.isaudio","title":"<code>isaudio</code>  <code>property</code>","text":"<p>Return True if asset is audio, otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.ismovie","title":"<code>ismovie</code>  <code>property</code>","text":"<p>Return True if asset is movie (video), otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.isphoto","title":"<code>isphoto</code>  <code>property</code>","text":"<p>Return True if asset is photo (image), otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.keywords","title":"<code>keywords: list[str]</code>  <code>property</code> <code>writable</code>","text":"<p>Keywords associated with asset</p>"},{"location":"reference/#photokit.PhotoAsset.live","title":"<code>live</code>  <code>property</code>","text":"<p>return True if asset is live, otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.local_identifier","title":"<code>local_identifier</code>  <code>property</code>","text":"<p>Return local identifier of PHAsset</p>"},{"location":"reference/#photokit.PhotoAsset.location","title":"<code>location: tuple[float, float] | None</code>  <code>property</code> <code>writable</code>","text":"<p>location of the asset as a tuple of (latitude, longitude) or None if no location</p>"},{"location":"reference/#photokit.PhotoAsset.media_subtypes","title":"<code>media_subtypes</code>  <code>property</code>","text":"<p>media subtype</p>"},{"location":"reference/#photokit.PhotoAsset.media_type","title":"<code>media_type</code>  <code>property</code>","text":"<p>media type such as image or video</p>"},{"location":"reference/#photokit.PhotoAsset.original_filename","title":"<code>original_filename</code>  <code>property</code>","text":"<p>Return original filename asset was imported with</p>"},{"location":"reference/#photokit.PhotoAsset.panorama","title":"<code>panorama</code>  <code>property</code>","text":"<p>return True if asset is panorama, otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.phasset","title":"<code>phasset</code>  <code>property</code>","text":"<p>Return PHAsset instance</p>"},{"location":"reference/#photokit.PhotoAsset.pixel_height","title":"<code>pixel_height</code>  <code>property</code>","text":"<p>height in pixels</p>"},{"location":"reference/#photokit.PhotoAsset.pixel_width","title":"<code>pixel_width</code>  <code>property</code>","text":"<p>width in pixels</p>"},{"location":"reference/#photokit.PhotoAsset.portrait","title":"<code>portrait</code>  <code>property</code>","text":"<p>return True if asset is portrait (depth effect), otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.raw_filename","title":"<code>raw_filename</code>  <code>property</code>","text":"<p>Return RAW filename for RAW+JPEG photos or None if no RAW asset</p>"},{"location":"reference/#photokit.PhotoAsset.screenshot","title":"<code>screenshot</code>  <code>property</code>","text":"<p>return True if asset is screenshot, otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.slow_mo","title":"<code>slow_mo</code>  <code>property</code>","text":"<p>return True if asset is slow motion (high frame rate) video, otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.source_type","title":"<code>source_type</code>  <code>property</code>","text":"<p>the means by which the asset entered the user's library</p>"},{"location":"reference/#photokit.PhotoAsset.streamed","title":"<code>streamed</code>  <code>property</code>","text":"<p>return True if asset is streamed video, otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.time_lapse","title":"<code>time_lapse</code>  <code>property</code>","text":"<p>return True if asset is time lapse video, otherwise False</p>"},{"location":"reference/#photokit.PhotoAsset.timezone","title":"<code>timezone: str</code>  <code>property</code> <code>writable</code>","text":"<p>The named timezone of the asset</p>"},{"location":"reference/#photokit.PhotoAsset.timezone_offset","title":"<code>timezone_offset: int</code>  <code>property</code> <code>writable</code>","text":"<p>Timezone offset (seconds from GMT) of the asset</p>"},{"location":"reference/#photokit.PhotoAsset.title","title":"<code>title: str</code>  <code>property</code> <code>writable</code>","text":"<p>Return title of asset</p>"},{"location":"reference/#photokit.PhotoAsset.uuid","title":"<code>uuid</code>  <code>property</code>","text":"<p>Return UUID of PHAsset. This is the same as the local identifier minus the added path component.</p>"},{"location":"reference/#photokit.PhotoAsset.__init__","title":"<code>__init__(library, phasset)</code>","text":"<p>Return a PhotoAsset object</p> <p>Parameters:</p> Name Type Description Default <code>library</code> <code>PhotoLibrary</code> <p>a PhotoLibrary object</p> required <code>phasset</code> <code>PHAsset</code> <p>a PHAsset object</p> required Source code in <code>photokit/asset.py</code> <pre><code>def __init__(self, library: PhotoLibrary, phasset: Photos.PHAsset):\n\"\"\"Return a PhotoAsset object\n\n    Args:\n        library: a PhotoLibrary object\n        phasset: a PHAsset object\n    \"\"\"\n    self._library = library\n    self._manager = self._library._phimagemanager\n    self._phasset = phasset\n</code></pre>"},{"location":"reference/#photokit.PhotoAsset.export","title":"<code>export(dest, filename=None, version=PHImageRequestOptionsVersionCurrent, overwrite=False, raw=False, **kwargs)</code>","text":"<p>Export image to path</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <p>str, path to destination directory</p> required <code>filename</code> <p>str, optional name of exported file; if not provided, defaults to asset's original filename</p> <code>None</code> <code>version</code> <p>which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)</p> <code>PHImageRequestOptionsVersionCurrent</code> <code>overwrite</code> <p>bool, if True, overwrites destination file if it already exists; default is False</p> <code>False</code> <code>raw</code> <p>bool, if True, export RAW component of RAW+JPEG pair, default is False</p> <code>False</code> <code>**kwargs</code> <p>used only to avoid issues with each asset type having slightly different export arguments</p> <code>{}</code> <p>Returns:</p> Type Description <p>List of path to exported image(s)</p> Source code in <code>photokit/asset.py</code> <pre><code>def export(\n    self,\n    dest,\n    filename=None,\n    version=PHImageRequestOptionsVersionCurrent,\n    overwrite=False,\n    raw=False,\n    **kwargs,\n):\n\"\"\"Export image to path\n\n    Args:\n        dest: str, path to destination directory\n        filename: str, optional name of exported file; if not provided, defaults to asset's original filename\n        version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n        overwrite: bool, if True, overwrites destination file if it already exists; default is False\n        raw: bool, if True, export RAW component of RAW+JPEG pair, default is False\n        **kwargs: used only to avoid issues with each asset type having slightly different export arguments\n\n    Returns:\n        List of path to exported image(s)\n\n    Raises:\n        ValueError if dest is not a valid directory\n    \"\"\"\n\n    with objc.autorelease_pool():\n        with pipes() as (out, err):\n            filename = (\n                pathlib.Path(filename)\n                if filename\n                else pathlib.Path(self.original_filename)\n            )\n\n            dest = pathlib.Path(dest)\n            if not dest.is_dir():\n                raise ValueError(\"dest must be a valid directory: {dest}\")\n\n            output_file = None\n            if self.isphoto:\n                # will hold exported image data and needs to be cleaned up at end\n                imagedata = None\n                if raw:\n                    # export the raw component\n                    resources = self._resources()\n                    for resource in resources:\n                        if (\n                            resource.type()\n                            == Photos.PHAssetResourceTypeAlternatePhoto\n                        ):\n                            data = self._request_resource_data(resource)\n                            suffix = pathlib.Path(self.raw_filename).suffix\n                            ext = suffix[1:] if suffix else \"\"\n                            break\n                    else:\n                        raise PhotoKitExportError(\n                            \"Could not get image data for RAW photo\"\n                        )\n                else:\n                    # TODO: if user has selected use RAW as original, this returns the RAW\n                    # can get the jpeg with resource.type() == Photos.PHAssetResourceTypePhoto\n                    imagedata = self._request_image_data(version=version)\n                    if not imagedata.image_data:\n                        raise PhotoKitExportError(\"Could not get image data\")\n                    ext = get_preferred_uti_extension(imagedata.uti)\n                    data = imagedata.image_data\n\n                output_file = dest / f\"{filename.stem}.{ext}\"\n\n                if not overwrite:\n                    output_file = pathlib.Path(increment_filename(output_file))\n\n                with open(output_file, \"wb\") as fd:\n                    fd.write(data)\n\n                if imagedata:\n                    del imagedata\n            elif self.ismovie:\n                videodata = self._request_video_data(version=version)\n                if videodata.asset is None:\n                    raise PhotoKitExportError(\"Could not get video for asset\")\n\n                url = videodata.asset.URL()\n                path = pathlib.Path(NSURL_to_path(url))\n                if not path.is_file():\n                    raise FileNotFoundError(\"Could not get path to video file\")\n                ext = path.suffix\n                output_file = dest / f\"{filename.stem}{ext}\"\n\n                if not overwrite:\n                    output_file = pathlib.Path(increment_filename(output_file))\n\n                FileUtil.copy(path, output_file)\n\n            return [str(output_file)]\n</code></pre>"},{"location":"reference/#photokit.PhotoAsset.metadata","title":"<code>metadata(version=PHImageRequestOptionsVersionCurrent)</code>","text":"<p>Return dict of asset metadata</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <p>which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)</p> <code>PHImageRequestOptionsVersionCurrent</code> Source code in <code>photokit/asset.py</code> <pre><code>def metadata(self, version=PHImageRequestOptionsVersionCurrent):\n\"\"\"Return dict of asset metadata\n\n    Args:\n        version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n    \"\"\"\n    imagedata = self._request_image_data(version=version)\n    return imagedata.metadata\n</code></pre>"},{"location":"reference/#photokit.PhotoAsset.orientation","title":"<code>orientation(version=PHImageRequestOptionsVersionCurrent)</code>","text":"<p>Return orientation of asset</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <p>which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)</p> <code>PHImageRequestOptionsVersionCurrent</code> Source code in <code>photokit/asset.py</code> <pre><code>def orientation(self, version=PHImageRequestOptionsVersionCurrent):\n\"\"\"Return orientation of asset\n\n    Args:\n        version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n    \"\"\"\n    imagedata = self._request_image_data(version=version)\n    return imagedata.orientation\n</code></pre>"},{"location":"reference/#photokit.PhotoAsset.path","title":"<code>path(version=PHImageRequestOptionsVersionCurrent)</code>","text":"<p>Return path of asset</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <p>which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)</p> <code>PHImageRequestOptionsVersionCurrent</code> Source code in <code>photokit/asset.py</code> <pre><code>def path(self, version=PHImageRequestOptionsVersionCurrent):\n\"\"\"Return path of asset\n\n    Args:\n        version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n    \"\"\"\n    imagedata = self._request_image_data(version=version)\n    url = imagedata.info[\"PHImageFileURLKey\"]\n    return url.fileSystemRepresentation().decode(\"utf-8\")\n</code></pre>"},{"location":"reference/#photokit.PhotoAsset.url","title":"<code>url(version=PHImageRequestOptionsVersionCurrent)</code>","text":"<p>Return URL of asset</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <p>which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)</p> <code>PHImageRequestOptionsVersionCurrent</code> Source code in <code>photokit/asset.py</code> <pre><code>def url(self, version=PHImageRequestOptionsVersionCurrent):\n\"\"\"Return URL of asset\n\n    Args:\n        version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n    \"\"\"\n    imagedata = self._request_image_data(version=version)\n    return str(imagedata.info[\"PHImageFileURLKey\"])\n</code></pre>"},{"location":"reference/#photokit.PhotoAsset.uti","title":"<code>uti(version=PHImageRequestOptionsVersionCurrent)</code>","text":"<p>Return UTI of asset</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <p>which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)</p> <code>PHImageRequestOptionsVersionCurrent</code> Source code in <code>photokit/asset.py</code> <pre><code>def uti(self, version=PHImageRequestOptionsVersionCurrent):\n\"\"\"Return UTI of asset\n\n    Args:\n        version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n    \"\"\"\n    imagedata = self._request_image_data(version=version)\n    return imagedata.uti\n</code></pre>"},{"location":"reference/#photokit.PhotoAsset.uti_raw","title":"<code>uti_raw()</code>","text":"<p>Return UTI of RAW component of RAW+JPEG pair</p> Source code in <code>photokit/asset.py</code> <pre><code>def uti_raw(self):\n\"\"\"Return UTI of RAW component of RAW+JPEG pair\"\"\"\n    resources = self._resources()\n    for resource in resources:\n        if (\n            self.isphoto\n            and resource.type() == Photos.PHAssetResourceTypeAlternatePhoto\n        ):\n            return resource.uniformTypeIdentifier()\n    return None\n</code></pre>"},{"location":"reference/#livephotoasset","title":"LivePhotoAsset","text":"<p>             Bases: <code>PhotoAsset</code></p> <p>Represents a live photo</p> Source code in <code>photokit/asset.py</code> <pre><code>class LivePhotoAsset(PhotoAsset):\n\"\"\"Represents a live photo\"\"\"\n\n    def export(\n        self,\n        dest,\n        filename=None,\n        version=PHImageRequestOptionsVersionCurrent,\n        overwrite=False,\n        photo=True,\n        video=True,\n        **kwargs,\n    ):\n\"\"\"Export image to path\n\n        Args:\n            dest: str, path to destination directory\n            filename: str, optional name of exported file; if not provided, defaults to asset's original filename\n            version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n            overwrite: bool, if True, overwrites destination file if it already exists; default is False\n            photo: bool, if True, export photo component of live photo\n            video: bool, if True, export live video component of live photo\n            **kwargs: used only to avoid issues with each asset type having slightly different export arguments\n\n        Returns:\n            list of [path to exported image and/or video]\n\n        Raises:\n            ValueError if dest is not a valid directory\n            PhotoKitExportError if error during export\n        \"\"\"\n\n        with objc.autorelease_pool():\n            with pipes() as (out, err):\n                filename = (\n                    pathlib.Path(filename)\n                    if filename\n                    else pathlib.Path(self.original_filename)\n                )\n\n                dest = pathlib.Path(dest)\n                if not dest.is_dir():\n                    raise ValueError(\"dest must be a valid directory: {dest}\")\n\n                request = _LivePhotoRequest.alloc().initWithManager_Asset_(\n                    self._manager, self.phasset\n                )\n                resources = request.requestLivePhotoResources(version=version)\n\n                video_resource = None\n                photo_resource = None\n                for resource in resources:\n                    if resource.type() == Photos.PHAssetResourceTypePairedVideo:\n                        video_resource = resource\n                    elif resource.type() == Photos.PHAssetMediaTypeImage:\n                        photo_resource = resource\n\n                if not video_resource or not photo_resource:\n                    raise PhotoKitExportError(\n                        \"Did not find photo/video resources for live photo\"\n                    )\n\n                photo_ext = get_preferred_uti_extension(\n                    photo_resource.uniformTypeIdentifier()\n                )\n                photo_output_file = dest / f\"{filename.stem}.{photo_ext}\"\n                video_ext = get_preferred_uti_extension(\n                    video_resource.uniformTypeIdentifier()\n                )\n                video_output_file = dest / f\"{filename.stem}.{video_ext}\"\n\n                if not overwrite:\n                    photo_output_file = pathlib.Path(\n                        increment_filename(photo_output_file)\n                    )\n                    video_output_file = pathlib.Path(\n                        increment_filename(video_output_file)\n                    )\n\n                exported = []\n                if photo:\n                    data = self._request_resource_data(photo_resource)\n                    # image_data = self.request_image_data(version=version)\n                    with open(photo_output_file, \"wb\") as fd:\n                        fd.write(data)\n                    exported.append(str(photo_output_file))\n                    del data\n                if video:\n                    data = self._request_resource_data(video_resource)\n                    with open(video_output_file, \"wb\") as fd:\n                        fd.write(data)\n                    exported.append(str(video_output_file))\n                    del data\n\n                request.dealloc()\n                return exported\n</code></pre>"},{"location":"reference/#photokit.LivePhotoAsset.export","title":"<code>export(dest, filename=None, version=PHImageRequestOptionsVersionCurrent, overwrite=False, photo=True, video=True, **kwargs)</code>","text":"<p>Export image to path</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <p>str, path to destination directory</p> required <code>filename</code> <p>str, optional name of exported file; if not provided, defaults to asset's original filename</p> <code>None</code> <code>version</code> <p>which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)</p> <code>PHImageRequestOptionsVersionCurrent</code> <code>overwrite</code> <p>bool, if True, overwrites destination file if it already exists; default is False</p> <code>False</code> <code>photo</code> <p>bool, if True, export photo component of live photo</p> <code>True</code> <code>video</code> <p>bool, if True, export live video component of live photo</p> <code>True</code> <code>**kwargs</code> <p>used only to avoid issues with each asset type having slightly different export arguments</p> <code>{}</code> <p>Returns:</p> Type Description <p>list of [path to exported image and/or video]</p> Source code in <code>photokit/asset.py</code> <pre><code>def export(\n    self,\n    dest,\n    filename=None,\n    version=PHImageRequestOptionsVersionCurrent,\n    overwrite=False,\n    photo=True,\n    video=True,\n    **kwargs,\n):\n\"\"\"Export image to path\n\n    Args:\n        dest: str, path to destination directory\n        filename: str, optional name of exported file; if not provided, defaults to asset's original filename\n        version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n        overwrite: bool, if True, overwrites destination file if it already exists; default is False\n        photo: bool, if True, export photo component of live photo\n        video: bool, if True, export live video component of live photo\n        **kwargs: used only to avoid issues with each asset type having slightly different export arguments\n\n    Returns:\n        list of [path to exported image and/or video]\n\n    Raises:\n        ValueError if dest is not a valid directory\n        PhotoKitExportError if error during export\n    \"\"\"\n\n    with objc.autorelease_pool():\n        with pipes() as (out, err):\n            filename = (\n                pathlib.Path(filename)\n                if filename\n                else pathlib.Path(self.original_filename)\n            )\n\n            dest = pathlib.Path(dest)\n            if not dest.is_dir():\n                raise ValueError(\"dest must be a valid directory: {dest}\")\n\n            request = _LivePhotoRequest.alloc().initWithManager_Asset_(\n                self._manager, self.phasset\n            )\n            resources = request.requestLivePhotoResources(version=version)\n\n            video_resource = None\n            photo_resource = None\n            for resource in resources:\n                if resource.type() == Photos.PHAssetResourceTypePairedVideo:\n                    video_resource = resource\n                elif resource.type() == Photos.PHAssetMediaTypeImage:\n                    photo_resource = resource\n\n            if not video_resource or not photo_resource:\n                raise PhotoKitExportError(\n                    \"Did not find photo/video resources for live photo\"\n                )\n\n            photo_ext = get_preferred_uti_extension(\n                photo_resource.uniformTypeIdentifier()\n            )\n            photo_output_file = dest / f\"{filename.stem}.{photo_ext}\"\n            video_ext = get_preferred_uti_extension(\n                video_resource.uniformTypeIdentifier()\n            )\n            video_output_file = dest / f\"{filename.stem}.{video_ext}\"\n\n            if not overwrite:\n                photo_output_file = pathlib.Path(\n                    increment_filename(photo_output_file)\n                )\n                video_output_file = pathlib.Path(\n                    increment_filename(video_output_file)\n                )\n\n            exported = []\n            if photo:\n                data = self._request_resource_data(photo_resource)\n                # image_data = self.request_image_data(version=version)\n                with open(photo_output_file, \"wb\") as fd:\n                    fd.write(data)\n                exported.append(str(photo_output_file))\n                del data\n            if video:\n                data = self._request_resource_data(video_resource)\n                with open(video_output_file, \"wb\") as fd:\n                    fd.write(data)\n                exported.append(str(video_output_file))\n                del data\n\n            request.dealloc()\n            return exported\n</code></pre>"},{"location":"reference/#videoasset","title":"VideoAsset","text":"<p>             Bases: <code>PhotoAsset</code></p> <p>PhotoKit PHAsset representation of video asset</p> Source code in <code>photokit/asset.py</code> <pre><code>class VideoAsset(PhotoAsset):\n\"\"\"PhotoKit PHAsset representation of video asset\"\"\"\n\n    # TODO: doesn't work for slow-mo videos\n    # see https://stackoverflow.com/questions/26152396/how-to-access-nsdata-nsurl-of-slow-motion-videos-using-photokit\n    # https://developer.apple.com/documentation/photokit/phimagemanager/1616935-requestavassetforvideo?language=objc\n    # https://developer.apple.com/documentation/photokit/phimagemanager/1616981-requestexportsessionforvideo?language=objc\n    # above 10.15 only\n    def export(\n        self,\n        dest,\n        filename=None,\n        version=PHImageRequestOptionsVersionCurrent,\n        overwrite=False,\n        **kwargs,\n    ):\n\"\"\"Export video to path\n\n        Args:\n            dest: str, path to destination directory\n            filename: str, optional name of exported file; if not provided, defaults to asset's original filename\n            version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n            overwrite: bool, if True, overwrites destination file if it already exists; default is False\n            **kwargs: used only to avoid issues with each asset type having slightly different export arguments\n\n        Returns:\n            List of path to exported image(s)\n\n        Raises:\n            ValueError if dest is not a valid directory\n        \"\"\"\n\n        with objc.autorelease_pool():\n            with pipes() as (out, err):\n                if self.slow_mo and version == PHImageRequestOptionsVersionCurrent:\n                    return [\n                        self._export_slow_mo(\n                            dest,\n                            filename=filename,\n                            version=version,\n                            overwrite=overwrite,\n                        )\n                    ]\n\n                filename = (\n                    pathlib.Path(filename)\n                    if filename\n                    else pathlib.Path(self.original_filename)\n                )\n\n                dest = pathlib.Path(dest)\n                if not dest.is_dir():\n                    raise ValueError(\"dest must be a valid directory: {dest}\")\n\n                output_file = None\n                videodata = self._request_video_data(version=version)\n                if videodata.asset is None:\n                    raise PhotoKitExportError(\"Could not get video for asset\")\n\n                url = videodata.asset.URL()\n                path = pathlib.Path(NSURL_to_path(url))\n                del videodata\n                if not path.is_file():\n                    raise FileNotFoundError(\"Could not get path to video file\")\n                ext = path.suffix\n                output_file = dest / f\"{filename.stem}{ext}\"\n\n                if not overwrite:\n                    output_file = pathlib.Path(increment_filename(output_file))\n\n                FileUtil.copy(path, output_file)\n\n                return [str(output_file)]\n\n    def _export_slow_mo(\n        self,\n        dest,\n        filename=None,\n        version=PHImageRequestOptionsVersionCurrent,\n        overwrite=False,\n    ):\n\"\"\"Export slow-motion video to path\n\n        Args:\n            dest: str, path to destination directory\n            filename: str, optional name of exported file; if not provided, defaults to asset's original filename\n            version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n            overwrite: bool, if True, overwrites destination file if it already exists; default is False\n\n        Returns:\n            Path to exported image\n\n        Raises:\n            ValueError if dest is not a valid directory\n        \"\"\"\n        with objc.autorelease_pool():\n            if not self.slow_mo:\n                raise PhotoKitMediaTypeError(\"Not a slow-mo video\")\n\n            videodata = self._request_video_data(version=version)\n            if (\n                not isinstance(videodata.asset, AVFoundation.AVComposition)\n                or len(videodata.asset.tracks()) != 2\n            ):\n                raise PhotoKitMediaTypeError(\"Does not appear to be slow-mo video\")\n\n            filename = (\n                pathlib.Path(filename)\n                if filename\n                else pathlib.Path(self.original_filename)\n            )\n\n            dest = pathlib.Path(dest)\n            if not dest.is_dir():\n                raise ValueError(\"dest must be a valid directory: {dest}\")\n\n            output_file = dest / f\"{filename.stem}.mov\"\n\n            if not overwrite:\n                output_file = pathlib.Path(increment_filename(output_file))\n\n            exporter = _SlowMoVideoExporter.alloc().initWithAVAsset_path_(\n                videodata.asset, output_file\n            )\n            video = exporter.exportSlowMoVideo()\n            # exporter.dealloc()\n            return video\n\n    # todo: rewrite this with NotificationCenter and App event loop?\n    def _request_video_data(self, version=PHImageRequestOptionsVersionOriginal):\n\"\"\"Request video data for self._phasset\n\n        Args:\n            version: which version to request\n                     PHImageRequestOptionsVersionOriginal (default), request original highest fidelity version\n                     PHImageRequestOptionsVersionCurrent, request current version with all edits\n                     PHImageRequestOptionsVersionUnadjusted, request highest quality unadjusted version\n\n        Raises:\n            ValueError if passed invalid value for version\n        \"\"\"\n        with objc.autorelease_pool():\n            if version not in [\n                PHImageRequestOptionsVersionCurrent,\n                PHImageRequestOptionsVersionOriginal,\n                PHImageRequestOptionsVersionUnadjusted,\n            ]:\n                raise ValueError(\"Invalid value for version\")\n\n            options_request = Photos.PHVideoRequestOptions.alloc().init()\n            options_request.setNetworkAccessAllowed_(True)\n            options_request.setVersion_(version)\n            options_request.setDeliveryMode_(\n                Photos.PHVideoRequestOptionsDeliveryModeHighQualityFormat\n            )\n            requestdata = AVAssetData()\n            event = threading.Event()\n\n            def handler(asset, audiomix, info):\n\"\"\"result handler for requestAVAssetForVideo:asset options:options resultHandler\"\"\"\n                nonlocal requestdata\n\n                requestdata.asset = asset\n                requestdata.audiomix = audiomix\n                requestdata.info = info\n\n                event.set()\n\n            self._manager.requestAVAssetForVideo_options_resultHandler_(\n                self.phasset, options_request, handler\n            )\n            event.wait()\n\n            # not sure why this is needed -- some weird ref count thing maybe\n            # if I don't do this, memory leaks\n            data = copy.copy(requestdata)\n            del requestdata\n            return data\n</code></pre>"},{"location":"reference/#photokit.VideoAsset.export","title":"<code>export(dest, filename=None, version=PHImageRequestOptionsVersionCurrent, overwrite=False, **kwargs)</code>","text":"<p>Export video to path</p> <p>Parameters:</p> Name Type Description Default <code>dest</code> <p>str, path to destination directory</p> required <code>filename</code> <p>str, optional name of exported file; if not provided, defaults to asset's original filename</p> <code>None</code> <code>version</code> <p>which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)</p> <code>PHImageRequestOptionsVersionCurrent</code> <code>overwrite</code> <p>bool, if True, overwrites destination file if it already exists; default is False</p> <code>False</code> <code>**kwargs</code> <p>used only to avoid issues with each asset type having slightly different export arguments</p> <code>{}</code> <p>Returns:</p> Type Description <p>List of path to exported image(s)</p> Source code in <code>photokit/asset.py</code> <pre><code>def export(\n    self,\n    dest,\n    filename=None,\n    version=PHImageRequestOptionsVersionCurrent,\n    overwrite=False,\n    **kwargs,\n):\n\"\"\"Export video to path\n\n    Args:\n        dest: str, path to destination directory\n        filename: str, optional name of exported file; if not provided, defaults to asset's original filename\n        version: which version of image (PHImageRequestOptionsVersionOriginal or PHImageRequestOptionsVersionCurrent)\n        overwrite: bool, if True, overwrites destination file if it already exists; default is False\n        **kwargs: used only to avoid issues with each asset type having slightly different export arguments\n\n    Returns:\n        List of path to exported image(s)\n\n    Raises:\n        ValueError if dest is not a valid directory\n    \"\"\"\n\n    with objc.autorelease_pool():\n        with pipes() as (out, err):\n            if self.slow_mo and version == PHImageRequestOptionsVersionCurrent:\n                return [\n                    self._export_slow_mo(\n                        dest,\n                        filename=filename,\n                        version=version,\n                        overwrite=overwrite,\n                    )\n                ]\n\n            filename = (\n                pathlib.Path(filename)\n                if filename\n                else pathlib.Path(self.original_filename)\n            )\n\n            dest = pathlib.Path(dest)\n            if not dest.is_dir():\n                raise ValueError(\"dest must be a valid directory: {dest}\")\n\n            output_file = None\n            videodata = self._request_video_data(version=version)\n            if videodata.asset is None:\n                raise PhotoKitExportError(\"Could not get video for asset\")\n\n            url = videodata.asset.URL()\n            path = pathlib.Path(NSURL_to_path(url))\n            del videodata\n            if not path.is_file():\n                raise FileNotFoundError(\"Could not get path to video file\")\n            ext = path.suffix\n            output_file = dest / f\"{filename.stem}{ext}\"\n\n            if not overwrite:\n                output_file = pathlib.Path(increment_filename(output_file))\n\n            FileUtil.copy(path, output_file)\n\n            return [str(output_file)]\n</code></pre>"},{"location":"reference/#album","title":"Album","text":"<p>Represents a PHAssetCollection</p> Source code in <code>photokit/album.py</code> <pre><code>class Album:\n\"\"\"Represents a PHAssetCollection\"\"\"\n\n    def __init__(\n        self, library: PhotoLibrary, collection: Photos.PHAssetCollection\n    ) -&gt; None:\n\"\"\"Initialize Album object with a PHAssetCollection\"\"\"\n        self._library = library\n        self._collection = collection\n\n    @property\n    def collection(self) -&gt; Photos.PHAssetCollection:\n\"\"\"Return the underlying PHAssetCollection\"\"\"\n        return self._collection\n\n    @property\n    def local_identifier(self) -&gt; str:\n\"\"\"Return the local identifier of the underlying PHAssetCollection\"\"\"\n        return self._collection.localIdentifier()\n\n    @property\n    def uuid(self) -&gt; str:\n\"\"\" \"Return the UUID of the underlying PHAssetCollection\"\"\"\n        return self._collection.localIdentifier().split(\"/\")[0]\n\n    @property\n    def title(self) -&gt; str:\n\"\"\"Return the localized title of the underlying PHAssetCollection\"\"\"\n        return self._collection.localizedTitle()\n\n    @property\n    def estimated_count(self) -&gt; int:\n\"\"\"Return the estimated number of assets in the underlying PHAssetCollection\"\"\"\n        return self._collection.estimatedAssetCount()\n\n    @property\n    def start_date(self) -&gt; datetime.datetime | None:\n\"\"\"Return the start date of the underlying PHAssetCollection as a naive datetime.datetime or None if no start date\"\"\"\n        start_date = self._collection.startDate()\n        return NSDate_to_datetime(start_date) if start_date else None\n\n    @property\n    def end_date(self) -&gt; datetime.datetime | None:\n\"\"\"Return the end date of the underlying PHAssetCollection as a naive datetime.datetime or None if no end date\"\"\"\n        end_date = self._collection.endDate()\n        return NSDate_to_datetime(end_date) if end_date else None\n\n    @property\n    def approximate_location(self) -&gt; Photos.CLLocation:\n\"\"\"Return the approximate location of the underlying PHAssetCollection\"\"\"\n        return self._collection.approximateLocation()\n\n    @property\n    def location_names(self) -&gt; list[str]:\n\"\"\"Return the location names of the underlying PHAssetCollection\"\"\"\n        return self._collection.localizedLocationNames()\n\n    def assets(self) -&gt; list[Photos.PHAsset]:\n\"\"\"Return a list of PHAssets in the underlying PHAssetCollection\"\"\"\n        assets = Photos.PHAsset.fetchAssetsInAssetCollection_options_(\n            self._collection, None\n        )\n        asset_list = []\n        for idx in range(assets.count()):\n            asset_list.append(self._library._asset_factory(assets.objectAtIndex_(idx)))\n        return asset_list\n\n    def add_assets(self, assets: list[Asset]):\n\"\"\"Add assets to the underlying album\n\n        Args:\n            assets: list of Asset objects to add to the album\n        \"\"\"\n\n        with objc.autorelease_pool():\n            event = threading.Event()\n\n            def completion_handler(success, error):\n                if error:\n                    raise PhotoKitAlbumAddAssetError(\n                        f\"Error adding asset assets to album {self}: {error}\"\n                    )\n                event.set()\n\n            def album_add_assets_handler(assets):\n                creation_request = Photos.PHAssetCollectionChangeRequest.changeRequestForAssetCollection_(\n                    self.collection\n                )\n                phassets = [a.phasset for a in assets]\n                creation_request.addAssets_(phassets)\n\n            self._library._phphotolibrary.performChanges_completionHandler_(\n                lambda: album_add_assets_handler(assets), completion_handler\n            )\n\n            event.wait()\n\n    def remove_assets(self, assets: list[Asset]):\n\"\"\"Remove assets from the underlying album\n\n        Args:\n            assets: list of Asset objects to remove from the album\n        \"\"\"\n\n        with objc.autorelease_pool():\n            event = threading.Event()\n\n            def completion_handler(success, error):\n                if error:\n                    raise PhotoKitAlbumAddAssetError(\n                        f\"Error adding asset assets to album {self}: {error}\"\n                    )\n                event.set()\n\n            def album_remove_assets_handler(assets):\n                creation_request = Photos.PHAssetCollectionChangeRequest.changeRequestForAssetCollection_(\n                    self.collection\n                )\n                phassets = [a.phasset for a in assets]\n                creation_request.removeAssets_(phassets)\n\n            self._library._phphotolibrary.performChanges_completionHandler_(\n                lambda: album_remove_assets_handler(assets), completion_handler\n            )\n\n            event.wait()\n\n    def __repr__(self) -&gt; str:\n\"\"\"Return string representation of Album object\"\"\"\n        return f\"Album('{self._collection.localizedTitle()}')\"\n\n    def __str__(self) -&gt; str:\n\"\"\"Return string representation of Album object\"\"\"\n        return f\"Album('{self._collection.localizedTitle()}')\"\n\n    def __len__(self) -&gt; int:\n\"\"\"Return number of assets in the album\"\"\"\n        return len(self.assets())\n</code></pre>"},{"location":"reference/#photokit.Album.approximate_location","title":"<code>approximate_location: Photos.CLLocation</code>  <code>property</code>","text":"<p>Return the approximate location of the underlying PHAssetCollection</p>"},{"location":"reference/#photokit.Album.collection","title":"<code>collection: Photos.PHAssetCollection</code>  <code>property</code>","text":"<p>Return the underlying PHAssetCollection</p>"},{"location":"reference/#photokit.Album.end_date","title":"<code>end_date: datetime.datetime | None</code>  <code>property</code>","text":"<p>Return the end date of the underlying PHAssetCollection as a naive datetime.datetime or None if no end date</p>"},{"location":"reference/#photokit.Album.estimated_count","title":"<code>estimated_count: int</code>  <code>property</code>","text":"<p>Return the estimated number of assets in the underlying PHAssetCollection</p>"},{"location":"reference/#photokit.Album.local_identifier","title":"<code>local_identifier: str</code>  <code>property</code>","text":"<p>Return the local identifier of the underlying PHAssetCollection</p>"},{"location":"reference/#photokit.Album.location_names","title":"<code>location_names: list[str]</code>  <code>property</code>","text":"<p>Return the location names of the underlying PHAssetCollection</p>"},{"location":"reference/#photokit.Album.start_date","title":"<code>start_date: datetime.datetime | None</code>  <code>property</code>","text":"<p>Return the start date of the underlying PHAssetCollection as a naive datetime.datetime or None if no start date</p>"},{"location":"reference/#photokit.Album.title","title":"<code>title: str</code>  <code>property</code>","text":"<p>Return the localized title of the underlying PHAssetCollection</p>"},{"location":"reference/#photokit.Album.uuid","title":"<code>uuid: str</code>  <code>property</code>","text":"<p>\"Return the UUID of the underlying PHAssetCollection</p>"},{"location":"reference/#photokit.Album.__init__","title":"<code>__init__(library, collection)</code>","text":"<p>Initialize Album object with a PHAssetCollection</p> Source code in <code>photokit/album.py</code> <pre><code>def __init__(\n    self, library: PhotoLibrary, collection: Photos.PHAssetCollection\n) -&gt; None:\n\"\"\"Initialize Album object with a PHAssetCollection\"\"\"\n    self._library = library\n    self._collection = collection\n</code></pre>"},{"location":"reference/#photokit.Album.__len__","title":"<code>__len__()</code>","text":"<p>Return number of assets in the album</p> Source code in <code>photokit/album.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Return number of assets in the album\"\"\"\n    return len(self.assets())\n</code></pre>"},{"location":"reference/#photokit.Album.__repr__","title":"<code>__repr__()</code>","text":"<p>Return string representation of Album object</p> Source code in <code>photokit/album.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return string representation of Album object\"\"\"\n    return f\"Album('{self._collection.localizedTitle()}')\"\n</code></pre>"},{"location":"reference/#photokit.Album.__str__","title":"<code>__str__()</code>","text":"<p>Return string representation of Album object</p> Source code in <code>photokit/album.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return string representation of Album object\"\"\"\n    return f\"Album('{self._collection.localizedTitle()}')\"\n</code></pre>"},{"location":"reference/#photokit.Album.add_assets","title":"<code>add_assets(assets)</code>","text":"<p>Add assets to the underlying album</p> <p>Parameters:</p> Name Type Description Default <code>assets</code> <code>list[Asset]</code> <p>list of Asset objects to add to the album</p> required Source code in <code>photokit/album.py</code> <pre><code>def add_assets(self, assets: list[Asset]):\n\"\"\"Add assets to the underlying album\n\n    Args:\n        assets: list of Asset objects to add to the album\n    \"\"\"\n\n    with objc.autorelease_pool():\n        event = threading.Event()\n\n        def completion_handler(success, error):\n            if error:\n                raise PhotoKitAlbumAddAssetError(\n                    f\"Error adding asset assets to album {self}: {error}\"\n                )\n            event.set()\n\n        def album_add_assets_handler(assets):\n            creation_request = Photos.PHAssetCollectionChangeRequest.changeRequestForAssetCollection_(\n                self.collection\n            )\n            phassets = [a.phasset for a in assets]\n            creation_request.addAssets_(phassets)\n\n        self._library._phphotolibrary.performChanges_completionHandler_(\n            lambda: album_add_assets_handler(assets), completion_handler\n        )\n\n        event.wait()\n</code></pre>"},{"location":"reference/#photokit.Album.assets","title":"<code>assets()</code>","text":"<p>Return a list of PHAssets in the underlying PHAssetCollection</p> Source code in <code>photokit/album.py</code> <pre><code>def assets(self) -&gt; list[Photos.PHAsset]:\n\"\"\"Return a list of PHAssets in the underlying PHAssetCollection\"\"\"\n    assets = Photos.PHAsset.fetchAssetsInAssetCollection_options_(\n        self._collection, None\n    )\n    asset_list = []\n    for idx in range(assets.count()):\n        asset_list.append(self._library._asset_factory(assets.objectAtIndex_(idx)))\n    return asset_list\n</code></pre>"},{"location":"reference/#photokit.Album.remove_assets","title":"<code>remove_assets(assets)</code>","text":"<p>Remove assets from the underlying album</p> <p>Parameters:</p> Name Type Description Default <code>assets</code> <code>list[Asset]</code> <p>list of Asset objects to remove from the album</p> required Source code in <code>photokit/album.py</code> <pre><code>def remove_assets(self, assets: list[Asset]):\n\"\"\"Remove assets from the underlying album\n\n    Args:\n        assets: list of Asset objects to remove from the album\n    \"\"\"\n\n    with objc.autorelease_pool():\n        event = threading.Event()\n\n        def completion_handler(success, error):\n            if error:\n                raise PhotoKitAlbumAddAssetError(\n                    f\"Error adding asset assets to album {self}: {error}\"\n                )\n            event.set()\n\n        def album_remove_assets_handler(assets):\n            creation_request = Photos.PHAssetCollectionChangeRequest.changeRequestForAssetCollection_(\n                self.collection\n            )\n            phassets = [a.phasset for a in assets]\n            creation_request.removeAssets_(phassets)\n\n        self._library._phphotolibrary.performChanges_completionHandler_(\n            lambda: album_remove_assets_handler(assets), completion_handler\n        )\n\n        event.wait()\n</code></pre>"}]}